shadow$provide.module$node_modules$crypto_js$lib_typedarrays = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core")) : "function" === typeof define && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      if ("function" == typeof ArrayBuffer) {
        var WordArray = CryptoJS.lib.WordArray, superInit = WordArray.init;
        (WordArray.init = function(typedArray) {
          typedArray instanceof ArrayBuffer && (typedArray = new Uint8Array(typedArray));
          if (typedArray instanceof Int8Array || "undefined" !== typeof Uint8ClampedArray && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            for (var typedArrayByteLength = typedArray.byteLength, words = [], i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        }).prototype = WordArray;
      }
    })();
    return CryptoJS.lib.WordArray;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$lib_typedarrays.js.map
