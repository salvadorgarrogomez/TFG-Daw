{
"version":3,
"file":"bide.impl.path.js",
"lineCount":201,
"mappings":"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",
"sources":["bide/impl/path.js"],
"sourcesContent":["/**\n * Path-to-Regex - Express-style path to regexp\n *\n * Is a modified and google closure adapted implementation of\n * https://github.com/pillarjs/path-to-regexp\n * @author Andrey Antukh <niwi@niwi.nz>, 2016-2017\n * @author Blake Embrey <hello@blakeembrey.com>, 2014\n * @license MIT License <https://opensource.org/licenses/MIT>\n */\n\n\"use strict\";\n\ngoog.provide(\"bide.impl.path\");\ngoog.require(\"bide.impl.helpers\");\n\ngoog.scope(function() {\n  var isArray = bide.impl.helpers.isArray;\n\n  /**\n   * The main path matching regexp utility.\n   *\n   * @type {RegExp}\n   */\n  var PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n    '([\\\\/.])?(?:(?:\\\\:([\\\\w\\\\-]+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n  ].join('|'), 'g');\n\n  /**\n   * Parse a string to the raw tokens.\n   *\n   * @param  {string} str\n   * @return {!Array}\n   */\n  function parseTokens (str) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var res;\n\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n      var m = res[0];\n      var escaped = res[1];\n      var offset = res.index;\n      path += str.slice(index, offset);\n      index = offset + m.length;\n\n      // Ignore already escaped sequences.\n      if (escaped) {\n        path += escaped[1];\n        continue;\n      }\n\n      var next = str[index];\n      var prefix = res[2];\n      var name = res[3];\n      var capture = res[4];\n      var group = res[5];\n      var modifier = res[6];\n      var asterisk = res[7];\n\n      // Push the current path onto the tokens.\n      if (path) {\n        tokens.push(path);\n        path = '';\n      }\n\n      var partial = prefix != null && next != null && next !== prefix;\n      var repeat = modifier === '+' || modifier === '*';\n      var optional = modifier === '?' || modifier === '*';\n      var delimiter = res[2] || '/';\n      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n      tokens.push({\n        name: name || key++,\n        prefix: prefix || '',\n        delimiter: delimiter,\n        optional: optional,\n        repeat: repeat,\n        partial: partial,\n        asterisk: !!asterisk,\n        pattern: escapeGroup(pattern)\n      });\n    }\n\n    // Match any characters still remaining.\n    if (index < str.length) {\n      path += str.substr(index);\n    }\n\n    // If the path exists, push it onto the end.\n    if (path) {\n      tokens.push(path);\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Prettier encoding of URI path segments.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n  function encodeURIComponentPretty (str) {\n    return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n  function encodeAsterisk (str) {\n    return encodeURI(str).replace(/[?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * Escape a regular expression string.\n   *\n   * @param  {string} str\n   * @return {string}\n   */\n  function escapeString (str) {\n    return str.replace(/([.+*?=^!:${}\\(\\)\\[\\]|\\/\\\\])/g, '\\\\$1');\n  }\n\n  /**\n   * Escape the capturing group by escaping special characters and meaning.\n   *\n   * @param  {string} group\n   * @return {string}\n   */\n  function escapeGroup (group) {\n    return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n  }\n\n  /**\n   * Get the flags for a regexp from the options.\n   *\n   * @param  {Object} options\n   * @return {string}\n   */\n  function flags (options) {\n    return options.sensitive ? '' : 'i';\n  }\n\n  /**\n   * Pull out keys from a regexp.\n   *\n   * @param  {!RegExp} path\n   * @param  {!Array}  keys\n   * @return {!RegExp}\n   */\n  function regexpToRegexp (path) {\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    var keys = [];\n\n    if (groups) {\n      for (var i = 0; i < groups.length; i++) {\n        keys.push({\n          name: i,\n          prefix: null,\n          delimiter: null,\n          optional: false,\n          repeat: false,\n          partial: false,\n          asterisk: false,\n          pattern: null\n        });\n      }\n    }\n\n    return [path, keys];\n  }\n\n  /**\n   * Expose a function for taking tokens and returning a RegExp.\n   *\n   * @param  {!Array}  tokens\n   * @param  {Object=} options\n   * @return {!RegExp}\n   */\n  function tokensToRegExp (tokens, options) {\n    options = options || {};\n\n    var strict = options.strict;\n    var end = options.end !== false;\n    var route = '';\n    var lastToken = tokens[tokens.length - 1];\n    var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken);\n\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        route += escapeString(token);\n      } else {\n        var prefix = escapeString(token.prefix);\n        var capture = '(?:' + token.pattern + ')';\n\n        if (token.repeat) {\n          capture += '(?:' + prefix + capture + ')*';\n        }\n\n        if (token.optional) {\n          if (!token.partial) {\n            capture = '(?:' + prefix + '(' + capture + '))?';\n          } else {\n            capture = prefix + '(' + capture + ')?';\n          }\n        } else {\n          capture = prefix + '(' + capture + ')';\n        }\n\n        route += capture;\n      }\n    }\n\n    // In non-strict mode we allow a slash at the end of match. If the path to\n    // match already ends with a slash, we remove it for consistency. The slash\n    // is valid at the end of a path match, not in the middle. This is important\n    // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n    if (!strict) {\n      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n    }\n\n    if (end) {\n      route += '$';\n    } else {\n      // In non-ending mode, we need the capturing groups to match as much as\n      // possible by using a positive lookahead to the end or next path segment.\n      route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n    }\n\n    return new RegExp('^' + route, flags(options));\n  }\n\n  /**\n   * Compile a string to a template function for the path tokens.\n   *\n   * @param  {!Array}             tokens\n   * @return {!function(Object=, Object=)}\n   */\n  function compileTokens (tokens) {\n    // Compile all the tokens into regexps.\n    var matches = new Array(tokens.length);\n\n    // Compile all the patterns before compilation.\n    for (var i = 0; i < tokens.length; i++) {\n      if (typeof tokens[i] === 'object') {\n        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n      }\n    }\n\n    return function (obj, opts) {\n      var path = '';\n      var data = obj || {};\n      var options = opts || {};\n      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          path += token;\n\n          continue;\n        }\n\n        var value = data[token.name];\n        var segment;\n\n        if (value == null) {\n          if (token.optional) {\n            // Prepend partial segment prefixes.\n            if (token.partial) {\n              path += token.prefix;\n            }\n\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to be defined');\n          }\n        }\n\n        if (isArray(value)) {\n          if (!token.repeat) {\n            throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n          }\n\n          if (value.length === 0) {\n            if (token.optional) {\n              continue;\n            } else {\n              throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n            }\n          }\n\n          for (var j = 0; j < value.length; j++) {\n            segment = encode(value[j]);\n\n            if (!matches[i].test(segment)) {\n              throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n            }\n\n            path += (j === 0 ? token.prefix : token.delimiter) + segment;\n          }\n\n          continue;\n        }\n\n        segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n        }\n\n        path += token.prefix + segment;\n      }\n\n      return path;\n    };\n  }\n\n  /**\n   * Create a path regexp from string input.\n   *\n   * @param  {string}  path\n   * @param  {!Array}  keys\n   * @param  {!Object} options\n   * @return {!RegExp}\n   */\n  function parse(path, options) {\n    if (options===undefined) options = {};\n\n    var tokens = parseTokens(path);\n    var re = tokensToRegExp(tokens, options);\n\n    // Attach keys back to the regexp.\n    var keys = [];\n    for (var i=0; i < tokens.length; i++) {\n      if (typeof tokens[i] !== 'string') {\n        keys.push(tokens[i]);\n      }\n    }\n\n    re._tokens = tokens;\n    re._keys = keys;\n    return re;\n  }\n\n  var self = bide.impl.path;\n  self.parse = parse;\n  self.compileTokens = compileTokens;\n});\n"],
"names":["goog","provide","require","scope","parseTokens","str","tokens","key","index","path","res","PATH_REGEXP","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","delimiter","pattern","escapeGroup","substr","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toString","toUpperCase","encodeAsterisk","escapeString","flags","options","sensitive","regexpToRegexp","groups","source","match","keys","i","tokensToRegExp","strict","end","route","lastToken","endsWithSlash","test","token","RegExp","compileTokens","matches","Array","obj","opts","data","encode","pretty","encodeURIComponent","value","segment","TypeError","isArray","JSON","stringify","j","parse","undefined","re","_tokens","_keys","bide","impl","helpers","join","self"]
}
