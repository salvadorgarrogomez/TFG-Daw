shadow$provide.module$node_modules$crypto_js$aes = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$enc_base64"), require("module$node_modules$crypto_js$md5"), require("module$node_modules$crypto_js$evpkdf"), require("module$node_modules$crypto_js$cipher_core")) : "function" === typeof define && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      var BlockCipher = CryptoJS.lib.BlockCipher, C_algo = CryptoJS.algo, SBOX = [], INV_SBOX = [], SUB_MIX_0 = [], SUB_MIX_1 = [], SUB_MIX_2 = [], SUB_MIX_3 = [], INV_SUB_MIX_0 = [], INV_SUB_MIX_1 = [], INV_SUB_MIX_2 = [], INV_SUB_MIX_3 = [];
      (function() {
        for (var d = [], i = 0; 256 > i; i++) {
          d[i] = 128 > i ? i << 1 : i << 1 ^ 283;
        }
        var x = 0, xi = 0;
        for (i = 0; 256 > i; i++) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x], x4 = d[x2], x8 = d[x4], t = 257 * d[sx] ^ 16843008 * sx;
          SUB_MIX_0[x] = t << 24 | t >>> 8;
          SUB_MIX_1[x] = t << 16 | t >>> 16;
          SUB_MIX_2[x] = t << 8 | t >>> 24;
          SUB_MIX_3[x] = t;
          t = 16843009 * x8 ^ 65537 * x4 ^ 257 * x2 ^ 16843008 * x;
          INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
          INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
          INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
          INV_SUB_MIX_3[sx] = t;
          x ? (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]) : x = xi = 1;
        }
      })();
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      C_algo = C_algo.AES = BlockCipher.extend({_doReset:function() {
        if (!this._nRounds || this._keyPriorReset !== this._key) {
          var t = this._keyPriorReset = this._key;
          for (var keyWords = t.words, keySize = t.sigBytes / 4, ksRows = 4 * ((this._nRounds = keySize + 6) + 1), keySchedule = this._keySchedule = [], ksRow = 0; ksRow < ksRows; ksRow++) {
            ksRow < keySize ? keySchedule[ksRow] = keyWords[ksRow] : (t = keySchedule[ksRow - 1], ksRow % keySize ? 6 < keySize && 4 == ksRow % keySize && (t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255]) : (t = t << 8 | t >>> 24, t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255], t ^= RCON[ksRow / keySize | 0] << 24), keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t);
          }
          keyWords = this._invKeySchedule = [];
          for (keySize = 0; keySize < ksRows; keySize++) {
            ksRow = ksRows - keySize, t = keySize % 4 ? keySchedule[ksRow] : keySchedule[ksRow - 4], keyWords[keySize] = 4 > keySize || 4 >= ksRow ? t : INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
          }
        }
      }, encryptBlock:function(M, offset) {
        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
      }, decryptBlock:function(M, offset) {
        var t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
        t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
      }, _doCryptBlock:function(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
        for (var nRounds = this._nRounds, s0 = M[offset] ^ keySchedule[0], s1 = M[offset + 1] ^ keySchedule[1], s2 = M[offset + 2] ^ keySchedule[2], s3 = M[offset + 3] ^ keySchedule[3], ksRow = 4, round = 1; round < nRounds; round++) {
          var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++], t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++], t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++];
          s3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++];
          s0 = t0;
          s1 = t1;
          s2 = t2;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        s3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        M[offset] = t0;
        M[offset + 1] = t1;
        M[offset + 2] = t2;
        M[offset + 3] = s3;
      }, keySize:8});
      CryptoJS.AES = BlockCipher._createHelper(C_algo);
    })();
    return CryptoJS.AES;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$aes.js.map
