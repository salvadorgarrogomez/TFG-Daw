shadow$provide.module$node_modules$crypto_js$sha3 = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$x64_core")) : "function" === typeof define && define.amd ? define(["./core", "./x64-core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function(Math) {
      var C_lib = CryptoJS.lib, WordArray = C_lib.WordArray, Hasher = C_lib.Hasher, X64Word = CryptoJS.x64.Word;
      C_lib = CryptoJS.algo;
      var RHO_OFFSETS = [], PI_INDEXES = [], ROUND_CONSTANTS = [];
      (function() {
        for (var x = 1, y = 0, t = 0; 24 > t; t++) {
          RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
          var newY = (2 * x + 3 * y) % 5;
          x = y % 5;
          y = newY;
        }
        for (x = 0; 5 > x; x++) {
          for (y = 0; 5 > y; y++) {
            PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
          }
        }
        x = 1;
        for (y = 0; 24 > y; y++) {
          for (var j = newY = t = 0; 7 > j; j++) {
            if (x & 1) {
              var bitPosition = (1 << j) - 1;
              32 > bitPosition ? newY ^= 1 << bitPosition : t ^= 1 << bitPosition - 32;
            }
            x = x & 128 ? x << 1 ^ 113 : x << 1;
          }
          ROUND_CONSTANTS[y] = X64Word.create(t, newY);
        }
      })();
      var T = [];
      (function() {
        for (var i = 0; 25 > i; i++) {
          T[i] = X64Word.create();
        }
      })();
      C_lib = C_lib.SHA3 = Hasher.extend({cfg:Hasher.cfg.extend({outputLength:512}), _doReset:function() {
        for (var state = this._state = [], i = 0; 25 > i; i++) {
          state[i] = new X64Word.init();
        }
        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
      }, _doProcessBlock:function(M, offset) {
        for (var state = this._state, nBlockSizeLanes = this.blockSize / 2, i = 0; i < nBlockSizeLanes; i++) {
          var M2i = M[offset + 2 * i], M2i1 = M[offset + 2 * i + 1];
          M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
          M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
          var lane = state[i];
          lane.high ^= M2i1;
          lane.low ^= M2i;
        }
        for (M = 0; 24 > M; M++) {
          for (offset = 0; 5 > offset; offset++) {
            for (M2i = M2i1 = nBlockSizeLanes = 0; 5 > M2i; M2i++) {
              lane = state[offset + 5 * M2i], nBlockSizeLanes ^= lane.high, M2i1 ^= lane.low;
            }
            lane = T[offset];
            lane.high = nBlockSizeLanes;
            lane.low = M2i1;
          }
          for (offset = 0; 5 > offset; offset++) {
            for (lane = T[(offset + 4) % 5], nBlockSizeLanes = T[(offset + 1) % 5], i = nBlockSizeLanes.high, M2i = nBlockSizeLanes.low, nBlockSizeLanes = lane.high ^ (i << 1 | M2i >>> 31), M2i1 = lane.low ^ (M2i << 1 | i >>> 31), M2i = 0; 5 > M2i; M2i++) {
              lane = state[offset + 5 * M2i], lane.high ^= nBlockSizeLanes, lane.low ^= M2i1;
            }
          }
          for (i = 1; 25 > i; i++) {
            lane = state[i], offset = lane.high, lane = lane.low, M2i = RHO_OFFSETS[i], 32 > M2i ? (nBlockSizeLanes = offset << M2i | lane >>> 32 - M2i, M2i1 = lane << M2i | offset >>> 32 - M2i) : (nBlockSizeLanes = lane << M2i - 32 | offset >>> 64 - M2i, M2i1 = offset << M2i - 32 | lane >>> 64 - M2i), lane = T[PI_INDEXES[i]], lane.high = nBlockSizeLanes, lane.low = M2i1;
          }
          lane = T[0];
          offset = state[0];
          lane.high = offset.high;
          lane.low = offset.low;
          for (offset = 0; 5 > offset; offset++) {
            for (M2i = 0; 5 > M2i; M2i++) {
              i = offset + 5 * M2i, lane = state[i], nBlockSizeLanes = T[i], i = T[(offset + 1) % 5 + 5 * M2i], M2i1 = T[(offset + 2) % 5 + 5 * M2i], lane.high = nBlockSizeLanes.high ^ ~i.high & M2i1.high, lane.low = nBlockSizeLanes.low ^ ~i.low & M2i1.low;
            }
          }
          lane = state[0];
          offset = ROUND_CONSTANTS[M];
          lane.high ^= offset.high;
          lane.low ^= offset.low;
        }
      }, _doFinalize:function() {
        var data = this._data, dataWords = data.words, nBitsLeft = 8 * data.sigBytes, blockSizeBits = 32 * this.blockSize;
        dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
        dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
        data.sigBytes = 4 * dataWords.length;
        this._process();
        data = this._state;
        dataWords = this.cfg.outputLength / 8;
        nBitsLeft = dataWords / 8;
        blockSizeBits = [];
        for (var i = 0; i < nBitsLeft; i++) {
          var lane = data[i], laneMsw = lane.high;
          lane = lane.low;
          laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
          lane = (lane << 8 | lane >>> 24) & 16711935 | (lane << 24 | lane >>> 8) & 4278255360;
          blockSizeBits.push(lane);
          blockSizeBits.push(laneMsw);
        }
        return new WordArray.init(blockSizeBits, dataWords);
      }, clone:function() {
        for (var clone = Hasher.clone.call(this), state = clone._state = this._state.slice(0), i = 0; 25 > i; i++) {
          state[i] = state[i].clone();
        }
        return clone;
      }});
      CryptoJS.SHA3 = Hasher._createHelper(C_lib);
      CryptoJS.HmacSHA3 = Hasher._createHmacHelper(C_lib);
    })(Math);
    return CryptoJS.SHA3;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$sha3.js.map
