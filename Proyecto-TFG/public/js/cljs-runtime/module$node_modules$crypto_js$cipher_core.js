shadow$provide.module$node_modules$crypto_js$cipher_core = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$evpkdf")) : "function" === typeof define && define.amd ? define(["./core", "./evpkdf"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    CryptoJS.lib.Cipher || function(undefined) {
      var C_lib = CryptoJS.lib, Base = C_lib.Base, WordArray = C_lib.WordArray, BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm, Base64 = CryptoJS.enc.Base64, EvpKDF = CryptoJS.algo.EvpKDF, Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({cfg:Base.extend(), createEncryptor:function(key, cfg) {
        return this.create(this._ENC_XFORM_MODE, key, cfg);
      }, createDecryptor:function(key, cfg) {
        return this.create(this._DEC_XFORM_MODE, key, cfg);
      }, init:function(xformMode, key, cfg) {
        this.cfg = this.cfg.extend(cfg);
        this._xformMode = xformMode;
        this._key = key;
        this.reset();
      }, reset:function() {
        BufferedBlockAlgorithm.reset.call(this);
        this._doReset();
      }, process:function(dataUpdate) {
        this._append(dataUpdate);
        return this._process();
      }, finalize:function(dataUpdate) {
        dataUpdate && this._append(dataUpdate);
        return this._doFinalize();
      }, keySize:4, ivSize:4, _ENC_XFORM_MODE:1, _DEC_XFORM_MODE:2, _createHelper:function() {
        return function(cipher) {
          return {encrypt:function(message, key, cfg) {
            return ("string" == typeof key ? PasswordBasedCipher : SerializableCipher).encrypt(cipher, message, key, cfg);
          }, decrypt:function(ciphertext, key, cfg) {
            return ("string" == typeof key ? PasswordBasedCipher : SerializableCipher).decrypt(cipher, ciphertext, key, cfg);
          }};
        };
      }()});
      C_lib.StreamCipher = Cipher.extend({_doFinalize:function() {
        return this._process(!0);
      }, blockSize:1});
      var C_mode = CryptoJS.mode = {}, BlockCipherMode = C_lib.BlockCipherMode = Base.extend({createEncryptor:function(cipher, iv) {
        return this.Encryptor.create(cipher, iv);
      }, createDecryptor:function(cipher, iv) {
        return this.Decryptor.create(cipher, iv);
      }, init:function(cipher, iv) {
        this._cipher = cipher;
        this._iv = iv;
      }});
      C_mode = C_mode.CBC = function() {
        function xorBlock(words, offset, blockSize) {
          var block;
          (block = this._iv) ? this._iv = undefined : block = this._prevBlock;
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= block[i];
          }
        }
        var CBC = BlockCipherMode.extend();
        CBC.Encryptor = CBC.extend({processBlock:function(words, offset) {
          var cipher = this._cipher, blockSize = cipher.blockSize;
          xorBlock.call(this, words, offset, blockSize);
          cipher.encryptBlock(words, offset);
          this._prevBlock = words.slice(offset, offset + blockSize);
        }});
        CBC.Decryptor = CBC.extend({processBlock:function(words, offset) {
          var cipher = this._cipher, blockSize = cipher.blockSize, thisBlock = words.slice(offset, offset + blockSize);
          cipher.decryptBlock(words, offset);
          xorBlock.call(this, words, offset, blockSize);
          this._prevBlock = thisBlock;
        }});
        return CBC;
      }();
      var Pkcs7 = (CryptoJS.pad = {}).Pkcs7 = {pad:function(data, blockSize) {
        blockSize *= 4;
        blockSize -= data.sigBytes % blockSize;
        for (var paddingWord = blockSize << 24 | blockSize << 16 | blockSize << 8 | blockSize, paddingWords = [], i = 0; i < blockSize; i += 4) {
          paddingWords.push(paddingWord);
        }
        blockSize = WordArray.create(paddingWords, blockSize);
        data.concat(blockSize);
      }, unpad:function(data) {
        data.sigBytes -= data.words[data.sigBytes - 1 >>> 2] & 255;
      }};
      C_lib.BlockCipher = Cipher.extend({cfg:Cipher.cfg.extend({mode:C_mode, padding:Pkcs7}), reset:function() {
        Cipher.reset.call(this);
        var modeCreator = this.cfg;
        var iv = modeCreator.iv, mode = modeCreator.mode;
        this._xformMode == this._ENC_XFORM_MODE ? modeCreator = mode.createEncryptor : (modeCreator = mode.createDecryptor, this._minBufferSize = 1);
        this._mode && this._mode.__creator == modeCreator ? this._mode.init(this, iv && iv.words) : (this._mode = modeCreator.call(mode, this, iv && iv.words), this._mode.__creator = modeCreator);
      }, _doProcessBlock:function(words, offset) {
        this._mode.processBlock(words, offset);
      }, _doFinalize:function() {
        var padding = this.cfg.padding;
        if (this._xformMode == this._ENC_XFORM_MODE) {
          padding.pad(this._data, this.blockSize);
          var finalProcessedBlocks = this._process(!0);
        } else {
          finalProcessedBlocks = this._process(!0), padding.unpad(finalProcessedBlocks);
        }
        return finalProcessedBlocks;
      }, blockSize:4});
      var CipherParams = C_lib.CipherParams = Base.extend({init:function(cipherParams) {
        this.mixIn(cipherParams);
      }, toString:function(formatter) {
        return (formatter || this.formatter).stringify(this);
      }});
      C_mode = (CryptoJS.format = {}).OpenSSL = {stringify:function(cipherParams) {
        var ciphertext = cipherParams.ciphertext;
        cipherParams = cipherParams.salt;
        return (cipherParams ? WordArray.create([1398893684, 1701076831]).concat(cipherParams).concat(ciphertext) : ciphertext).toString(Base64);
      }, parse:function(openSSLStr) {
        openSSLStr = Base64.parse(openSSLStr);
        var ciphertextWords = openSSLStr.words;
        if (1398893684 == ciphertextWords[0] && 1701076831 == ciphertextWords[1]) {
          var salt = WordArray.create(ciphertextWords.slice(2, 4));
          ciphertextWords.splice(0, 4);
          openSSLStr.sigBytes -= 16;
        }
        return CipherParams.create({ciphertext:openSSLStr, salt});
      }};
      var SerializableCipher = C_lib.SerializableCipher = Base.extend({cfg:Base.extend({format:C_mode}), encrypt:function(cipher, message, key, cfg) {
        cfg = this.cfg.extend(cfg);
        var encryptor = cipher.createEncryptor(key, cfg);
        message = encryptor.finalize(message);
        encryptor = encryptor.cfg;
        return CipherParams.create({ciphertext:message, key, iv:encryptor.iv, algorithm:cipher, mode:encryptor.mode, padding:encryptor.padding, blockSize:cipher.blockSize, formatter:cfg.format});
      }, decrypt:function(cipher, ciphertext, key, cfg) {
        cfg = this.cfg.extend(cfg);
        ciphertext = this._parse(ciphertext, cfg.format);
        return cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
      }, _parse:function(ciphertext, format) {
        return "string" == typeof ciphertext ? format.parse(ciphertext, this) : ciphertext;
      }});
      Base = (CryptoJS.kdf = {}).OpenSSL = {execute:function(password, keySize, ivSize, salt, hasher) {
        salt || (salt = WordArray.random(8));
        password = hasher ? EvpKDF.create({keySize:keySize + ivSize, hasher}).compute(password, salt) : EvpKDF.create({keySize:keySize + ivSize}).compute(password, salt);
        ivSize = WordArray.create(password.words.slice(keySize), 4 * ivSize);
        password.sigBytes = 4 * keySize;
        return CipherParams.create({key:password, iv:ivSize, salt});
      }};
      var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:Base}), encrypt:function(cipher, message, password, cfg) {
        cfg = this.cfg.extend(cfg);
        password = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
        cfg.iv = password.iv;
        cipher = SerializableCipher.encrypt.call(this, cipher, message, password.key, cfg);
        cipher.mixIn(password);
        return cipher;
      }, decrypt:function(cipher, ciphertext, password, cfg) {
        cfg = this.cfg.extend(cfg);
        ciphertext = this._parse(ciphertext, cfg.format);
        password = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
        cfg.iv = password.iv;
        return SerializableCipher.decrypt.call(this, cipher, ciphertext, password.key, cfg);
      }});
    }();
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$cipher_core.js.map
