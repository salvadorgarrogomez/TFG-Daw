{
"version":3,
"file":"goog.loader.activemodulemanager.js",
"lineCount":61,
"mappings":"AAAA,IAAA,CAAA,UAAA,CAAA,QAAA,CAAA,OAAA,CAAA;AA+BAA,UAASA,UAAS,CAACC,WAAD,CAAc;AAC9B,QAAIC,aAAJ;AACED,iBAAA,CAAYC,aAAZ,CAAA;AADF;AAGEC,wBAAmBC,CAAAA,IAAnB,CAAwBH,WAAxB,CAAA;AAHF;AAD8B;AAYhCI,UAASA,IAAG,EAAG;AACb,QAAI,CAACH,aAAL,IAAsBI,UAAtB;AACEC,SAAA,CAAID,UAAA,EAAJ,CAAA;AADF;AAGAE,WAAQC,CAAAA,MAAR,CACIP,aADJ,IACqB,IADrB,EAC2B,0CAD3B,CAAA;AAEA,WAAOA,aAAP;AANa;AAefK,UAASA,IAAG,CAACG,gBAAD,CAAmB;AAC7BF,WAAQC,CAAAA,MAAR,CACIP,aADJ,IACqB,IADrB,EAC2B,yCAD3B,CAAA;AAEAA,iBAAA,GAAgBQ,gBAAhB;AACAP,sBAAmBQ,CAAAA,OAAnB,CAA2BV,WAAA,IAAe;AACxCA,iBAAA,CAAmDC,aAAnD,CAAA;AADwC,KAA1C,CAAA;AAGAC,sBAAA,GAAqB,EAArB;AAP6B;AAe/BS,UAASA,WAAU,CAACC,EAAD,CAAK;AACtBP,cAAA,GAAaO,EAAb;AADsB;AAQxBC,UAASA,qBAAoB,CAACC,EAAD,CAAK;AAChC,QAAIb,aAAJ;AACEA,mBAAcY,CAAAA,oBAAd,CAAmCC,EAAnC,CAAA;AADF;AADgC;AAYlCC,UAASA,UAAS,EAAG;AACnB,QAAId,aAAJ;AACEA,mBAAcc,CAAAA,SAAd,EAAA;AADF;AADmB;AAcrBC,UAASA,gBAAe,CAACC,IAAD,EAAOC,gBAAP,CAAyB;AAC/C,QAAI,CAACjB,aAAL,CAAoB;AAClB,UAAI,CAACI,UAAL;AAAiB;AAAjB;AACAC,SAAA,CAAID,UAAA,EAAJ,CAAA;AAFkB;AAIpBJ,iBAAckB,CAAAA,sBAAd,CAAqCF,IAArC,EAA2CC,gBAA3C,CAAA;AAL+C;AA3GjD,cAAA;AAUAE,MAAKC,CAAAA,MAAL,CAAY,iCAAZ,CAAA;AACAD,MAAKC,CAAAA,MAAOC,CAAAA,sBAAZ,EAAA;AAEA,QAAMC,wBAAwBH,IAAKI,CAAAA,OAAL,CAAa,mCAAb,CAA9B;AACA,QAAMjB,UAAUa,IAAKI,CAAAA,OAAL,CAAa,cAAb,CAAhB;AAGA,MAAIvB,gBAAgB,IAApB;AAGA,MAAII,aAAa,IAAjB;AAGA,MAAIH,qBAAqB,EAAzB;AA6FA,QAAMuB,QAAQA,QAAQ,EAAG;AACvBxB,iBAAA,GAAgB,IAAhB;AACAC,sBAAA,GAAqB,EAArB;AAFuB,GAAzB;AAKAwB,SAAA,GAAU,CACRtB,GADQ,EAERE,GAFQ,EAGRK,UAHQ,EAIRE,oBAJQ,EAKRE,SALQ,EAMRC,eANQ,EAORS,KAPQ,EAQR1B,SARQ,CAAV;AAzHA,SAAA,OAAA;AAAA,CAAA,CAAA;;",
"sources":["goog/loader/activemodulemanager.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A singleton interface for managing JavaScript code modules.\n */\n\ngoog.module('goog.loader.activeModuleManager');\ngoog.module.declareLegacyNamespace();\n\nconst AbstractModuleManager = goog.require('goog.loader.AbstractModuleManager');\nconst asserts = goog.require('goog.asserts');\n\n/** @type {?AbstractModuleManager} */\nlet moduleManager = null;\n\n/** @type {?function(): !AbstractModuleManager} */\nlet getDefault = null;\n\n/** @type {!Array<function(!AbstractModuleManager)>} */\nlet configureFunctions = [];\n\n/**\n * Applys a configuration function on moduleManager if it exists. Otherwise\n * store the configuration function inside of configureFunctions list so\n * that they can be applied when moduleManager is instantiated.\n * @param {function(!AbstractModuleManager)} configureFn\n */\nfunction configure(configureFn) {\n  if (moduleManager) {\n    configureFn(moduleManager);\n  } else {\n    configureFunctions.push(configureFn);\n  }\n}\n\n/**\n * Gets the active module manager, instantiating one if necessary.\n * @return {!AbstractModuleManager}\n */\nfunction get() {\n  if (!moduleManager && getDefault) {\n    set(getDefault());\n  }\n  asserts.assert(\n      moduleManager != null, 'The module manager has not yet been set.');\n  return moduleManager;\n}\n\n/**\n * Sets the active module manager. This should never be used to override an\n * existing manager.\n *\n * @param {!AbstractModuleManager} newModuleManager\n */\nfunction set(newModuleManager) {\n  asserts.assert(\n      moduleManager == null, 'The module manager cannot be redefined.');\n  moduleManager = newModuleManager;\n  configureFunctions.forEach(configureFn => {\n    configureFn(/** @type {!AbstractModuleManager} */ (moduleManager));\n  });\n  configureFunctions = [];\n}\n\n/**\n * Stores a callback that will be used  to get an AbstractModuleManager instance\n * if set() is not called before the first get() call.\n * @param {function(): !AbstractModuleManager} fn\n */\nfunction setDefault(fn) {\n  getDefault = fn;\n}\n\n/**\n * Method called just before module code is loaded.\n * @param {string} id Identifier of the module.\n */\nfunction beforeLoadModuleCode(id) {\n  if (moduleManager) {\n    moduleManager.beforeLoadModuleCode(id);\n  }\n}\n\n/**\n * Records that the currently loading module was loaded. Also initiates loading\n * the next module if any module requests are queued. This method is called by\n * code that is generated and appended to each dynamic module's code at\n * compilation time.\n */\nfunction setLoaded() {\n  if (moduleManager) {\n    moduleManager.setLoaded();\n  }\n}\n\n/**\n * Initialize the module manager.\n * @param {string=} info A string representation of the module dependency\n *      graph, in the form: module1:dep1,dep2/module2:dep1,dep2 etc.\n *     Where depX is the base-36 encoded position of the dep in the module list.\n * @param {!Array<string>=} loadingModuleIds A list of moduleIds that\n *     are currently being loaded.\n */\nfunction maybeInitialize(info, loadingModuleIds) {\n  if (!moduleManager) {\n    if (!getDefault) return;\n    set(getDefault());\n  }\n  moduleManager.setAllModuleInfoString(info, loadingModuleIds);\n}\n\n/** Test-only method for removing the active module manager. */\nconst reset = function() {\n  moduleManager = null;\n  configureFunctions = [];\n};\n\nexports = {\n  get,\n  set,\n  setDefault,\n  beforeLoadModuleCode,\n  setLoaded,\n  maybeInitialize,\n  reset,\n  configure,\n};\n"],
"names":["configure","configureFn","moduleManager","configureFunctions","push","get","getDefault","set","asserts","assert","newModuleManager","forEach","setDefault","fn","beforeLoadModuleCode","id","setLoaded","maybeInitialize","info","loadingModuleIds","setAllModuleInfoString","goog","module","declareLegacyNamespace","AbstractModuleManager","require","reset","exports"]
}
