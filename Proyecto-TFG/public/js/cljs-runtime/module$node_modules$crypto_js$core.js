shadow$provide.module$node_modules$crypto_js$core = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory() : "function" === typeof define && define.amd ? define([], factory) : root.CryptoJS = factory();
  })(this, function() {
    var CryptoJS = CryptoJS || function(Math, undefined) {
      if ("undefined" !== typeof window && window.crypto) {
        var crypto = window.crypto;
      }
      "undefined" !== typeof self && self.crypto && (crypto = self.crypto);
      "undefined" !== typeof globalThis && globalThis.crypto && (crypto = globalThis.crypto);
      !crypto && "undefined" !== typeof window && window.msCrypto && (crypto = window.msCrypto);
      !crypto && "undefined" !== typeof global && global.crypto && (crypto = global.crypto);
      if (!crypto && "function" === typeof require) {
        try {
          crypto = require("shadow$empty");
        } catch (err) {
        }
      }
      var create = Object.create || function() {
        function F() {
        }
        return function(obj) {
          F.prototype = obj;
          obj = new F();
          F.prototype = null;
          return obj;
        };
      }(), C = {}, C_lib = C.lib = {}, Base = C_lib.Base = function() {
        return {extend:function(overrides) {
          var subtype = create(this);
          overrides && subtype.mixIn(overrides);
          subtype.hasOwnProperty("init") && this.init !== subtype.init || (subtype.init = function() {
            subtype.$super.init.apply(this, arguments);
          });
          subtype.init.prototype = subtype;
          subtype.$super = this;
          return subtype;
        }, create:function() {
          var instance = this.extend();
          instance.init.apply(instance, arguments);
          return instance;
        }, init:function() {
        }, mixIn:function(properties) {
          for (var propertyName in properties) {
            properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]);
          }
          properties.hasOwnProperty("toString") && (this.toString = properties.toString);
        }, clone:function() {
          return this.init.prototype.extend(this);
        }};
      }(), WordArray = C_lib.WordArray = Base.extend({init:function(words, sigBytes) {
        words = this.words = words || [];
        this.sigBytes = undefined != sigBytes ? sigBytes : 4 * words.length;
      }, toString:function(encoder) {
        return (encoder || Hex).stringify(this);
      }, concat:function(wordArray) {
        var thisWords = this.words, thatWords = wordArray.words, thisSigBytes = this.sigBytes;
        wordArray = wordArray.sigBytes;
        this.clamp();
        if (thisSigBytes % 4) {
          for (var i = 0; i < wordArray; i++) {
            thisWords[thisSigBytes + i >>> 2] |= (thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 24 - (thisSigBytes + i) % 4 * 8;
          }
        } else {
          for (i = 0; i < wordArray; i += 4) {
            thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
          }
        }
        this.sigBytes += wordArray;
        return this;
      }, clamp:function() {
        var words = this.words, sigBytes = this.sigBytes;
        words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
        words.length = Math.ceil(sigBytes / 4);
      }, clone:function() {
        var clone = Base.clone.call(this);
        clone.words = this.words.slice(0);
        return clone;
      }, random:function(nBytes) {
        for (var words = [], i = 0; i < nBytes; i += 4) {
          var JSCompiler_temp_const = words, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.push;
          a: {
            if (crypto) {
              if ("function" === typeof crypto.getRandomValues) {
                try {
                  var JSCompiler_inline_result = crypto.getRandomValues(new Uint32Array(1))[0];
                  break a;
                } catch (err) {
                }
              }
              if ("function" === typeof crypto.randomBytes) {
                try {
                  JSCompiler_inline_result = crypto.randomBytes(4).readInt32LE();
                  break a;
                } catch (err) {
                }
              }
            }
            throw Error("Native crypto module could not be used to get secure random number.");
          }
          JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, JSCompiler_inline_result);
        }
        return new WordArray.init(words, nBytes);
      }}), C_enc = C.enc = {}, Hex = C_enc.Hex = {stringify:function(wordArray) {
        var words = wordArray.words;
        wordArray = wordArray.sigBytes;
        for (var hexChars = [], i = 0; i < wordArray; i++) {
          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
          hexChars.push((bite >>> 4).toString(16));
          hexChars.push((bite & 15).toString(16));
        }
        return hexChars.join("");
      }, parse:function(hexStr) {
        for (var hexStrLength = hexStr.length, words = [], i = 0; i < hexStrLength; i += 2) {
          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
        }
        return new WordArray.init(words, hexStrLength / 2);
      }}, Latin1 = C_enc.Latin1 = {stringify:function(wordArray) {
        var words = wordArray.words;
        wordArray = wordArray.sigBytes;
        for (var latin1Chars = [], i = 0; i < wordArray; i++) {
          latin1Chars.push(String.fromCharCode(words[i >>> 2] >>> 24 - i % 4 * 8 & 255));
        }
        return latin1Chars.join("");
      }, parse:function(latin1Str) {
        for (var latin1StrLength = latin1Str.length, words = [], i = 0; i < latin1StrLength; i++) {
          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
        }
        return new WordArray.init(words, latin1StrLength);
      }}, Utf8 = C_enc.Utf8 = {stringify:function(wordArray) {
        try {
          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
        } catch (e) {
          throw Error("Malformed UTF-8 data");
        }
      }, parse:function(utf8Str) {
        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
      }}, BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({reset:function() {
        this._data = new WordArray.init();
        this._nDataBytes = 0;
      }, _append:function(data) {
        "string" == typeof data && (data = Utf8.parse(data));
        this._data.concat(data);
        this._nDataBytes += data.sigBytes;
      }, _process:function(doFlush) {
        var processedWords, data = this._data, dataWords = data.words, dataSigBytes = data.sigBytes, blockSize = this.blockSize, nBlocksReady = dataSigBytes / (4 * blockSize);
        nBlocksReady = doFlush ? Math.ceil(nBlocksReady) : Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
        doFlush = nBlocksReady * blockSize;
        dataSigBytes = Math.min(4 * doFlush, dataSigBytes);
        if (doFlush) {
          for (processedWords = 0; processedWords < doFlush; processedWords += blockSize) {
            this._doProcessBlock(dataWords, processedWords);
          }
          processedWords = dataWords.splice(0, doFlush);
          data.sigBytes -= dataSigBytes;
        }
        return new WordArray.init(processedWords, dataSigBytes);
      }, clone:function() {
        var clone = Base.clone.call(this);
        clone._data = this._data.clone();
        return clone;
      }, _minBufferSize:0});
      C_lib.Hasher = BufferedBlockAlgorithm.extend({cfg:Base.extend(), init:function(cfg) {
        this.cfg = this.cfg.extend(cfg);
        this.reset();
      }, reset:function() {
        BufferedBlockAlgorithm.reset.call(this);
        this._doReset();
      }, update:function(messageUpdate) {
        this._append(messageUpdate);
        this._process();
        return this;
      }, finalize:function(messageUpdate) {
        messageUpdate && this._append(messageUpdate);
        return this._doFinalize();
      }, blockSize:16, _createHelper:function(hasher) {
        return function(message, cfg) {
          return (new hasher.init(cfg)).finalize(message);
        };
      }, _createHmacHelper:function(hasher) {
        return function(message, key) {
          return (new C_algo.HMAC.init(hasher, key)).finalize(message);
        };
      }});
      var C_algo = C.algo = {};
      return C;
    }(Math);
    return CryptoJS;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$core.js.map
