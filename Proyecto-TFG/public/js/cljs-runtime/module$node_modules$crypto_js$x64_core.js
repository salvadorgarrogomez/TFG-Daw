shadow$provide.module$node_modules$crypto_js$x64_core = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core")) : "function" === typeof define && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function(undefined) {
      var C_lib = CryptoJS.lib, Base = C_lib.Base, X32WordArray = C_lib.WordArray;
      C_lib = CryptoJS.x64 = {};
      C_lib.Word = Base.extend({init:function(high, low) {
        this.high = high;
        this.low = low;
      }});
      C_lib.WordArray = Base.extend({init:function(words, sigBytes) {
        words = this.words = words || [];
        this.sigBytes = undefined != sigBytes ? sigBytes : 8 * words.length;
      }, toX32:function() {
        for (var x64Words = this.words, x64WordsLength = x64Words.length, x32Words = [], i = 0; i < x64WordsLength; i++) {
          var x64Word = x64Words[i];
          x32Words.push(x64Word.high);
          x32Words.push(x64Word.low);
        }
        return X32WordArray.create(x32Words, this.sigBytes);
      }, clone:function() {
        for (var clone = Base.clone.call(this), words = clone.words = this.words.slice(0), wordsLength = words.length, i = 0; i < wordsLength; i++) {
          words[i] = words[i].clone();
        }
        return clone;
      }});
    })();
    return CryptoJS;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$x64_core.js.map
