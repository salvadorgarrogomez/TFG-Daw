shadow$provide.module$node_modules$crypto_js$mode_ctr_gladman = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$cipher_core")) : "function" === typeof define && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    CryptoJS.mode.CTRGladman = function() {
      function incWord(word) {
        if (255 === (word >> 24 & 255)) {
          var b1 = word >> 16 & 255, b2 = word >> 8 & 255, b3 = word & 255;
          255 === b1 ? (b1 = 0, 255 === b2 ? (b2 = 0, 255 === b3 ? b3 = 0 : ++b3) : ++b2) : ++b1;
          word = b1 << 16;
          word += b2 << 8;
          word += b3;
        } else {
          word += 16777216;
        }
        return word;
      }
      var CTRGladman = CryptoJS.lib.BlockCipherMode.extend(), Encryptor = CTRGladman.Encryptor = CTRGladman.extend({processBlock:function(words, offset) {
        var cipher = this._cipher, blockSize = cipher.blockSize, iv = this._iv, counter = this._counter;
        iv && (counter = this._counter = iv.slice(0), this._iv = void 0);
        iv = counter;
        0 === (iv[0] = incWord(iv[0])) && (iv[1] = incWord(iv[1]));
        counter = counter.slice(0);
        cipher.encryptBlock(counter, 0);
        for (cipher = 0; cipher < blockSize; cipher++) {
          words[offset + cipher] ^= counter[cipher];
        }
      }});
      CTRGladman.Decryptor = Encryptor;
      return CTRGladman;
    }();
    return CryptoJS.mode.CTRGladman;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$mode_ctr_gladman.js.map
