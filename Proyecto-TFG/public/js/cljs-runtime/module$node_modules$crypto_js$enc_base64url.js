shadow$provide.module$node_modules$crypto_js$enc_base64url = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core")) : "function" === typeof define && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      var WordArray = CryptoJS.lib.WordArray;
      CryptoJS.enc.Base64url = {stringify:function(wordArray, urlSafe) {
        void 0 === urlSafe && (urlSafe = !0);
        var words = wordArray.words, sigBytes = wordArray.sigBytes;
        urlSafe = urlSafe ? this._safe_map : this._map;
        wordArray.clamp();
        wordArray = [];
        for (var i = 0; i < sigBytes; i += 3) {
          for (var triplet = (words[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, j = 0; 4 > j && i + 0.75 * j < sigBytes; j++) {
            wordArray.push(urlSafe.charAt(triplet >>> 6 * (3 - j) & 63));
          }
        }
        if (words = urlSafe.charAt(64)) {
          for (; wordArray.length % 4;) {
            wordArray.push(words);
          }
        }
        return wordArray.join("");
      }, parse:function(base64Str, urlSafe) {
        void 0 === urlSafe && (urlSafe = !0);
        var base64StrLength = base64Str.length, map = urlSafe ? this._safe_map : this._map;
        urlSafe = this._reverseMap;
        if (!urlSafe) {
          urlSafe = this._reverseMap = [];
          for (var j = 0; j < map.length; j++) {
            urlSafe[map.charCodeAt(j)] = j;
          }
        }
        if (map = map.charAt(64)) {
          map = base64Str.indexOf(map), -1 !== map && (base64StrLength = map);
        }
        map = [];
        for (var i = j = 0; i < base64StrLength; i++) {
          if (i % 4) {
            var bits1 = urlSafe[base64Str.charCodeAt(i - 1)] << i % 4 * 2, bits2 = urlSafe[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
            map[j >>> 2] |= (bits1 | bits2) << 24 - j % 4 * 8;
            j++;
          }
        }
        return WordArray.create(map, j);
      }, _map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d", _safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"};
    })();
    return CryptoJS.enc.Base64url;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$enc_base64url.js.map
