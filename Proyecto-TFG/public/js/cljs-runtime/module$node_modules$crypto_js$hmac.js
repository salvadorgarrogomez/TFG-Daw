shadow$provide.module$node_modules$crypto_js$hmac = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core")) : "function" === typeof define && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      var Utf8 = CryptoJS.enc.Utf8;
      CryptoJS.algo.HMAC = CryptoJS.lib.Base.extend({init:function(hasher, key) {
        hasher = this._hasher = new hasher.init();
        "string" == typeof key && (key = Utf8.parse(key));
        var hasherBlockSize = hasher.blockSize, hasherBlockSizeBytes = 4 * hasherBlockSize;
        key.sigBytes > hasherBlockSizeBytes && (key = hasher.finalize(key));
        key.clamp();
        hasher = this._oKey = key.clone();
        key = this._iKey = key.clone();
        for (var oKeyWords = hasher.words, iKeyWords = key.words, i = 0; i < hasherBlockSize; i++) {
          oKeyWords[i] ^= 1549556828, iKeyWords[i] ^= 909522486;
        }
        hasher.sigBytes = key.sigBytes = hasherBlockSizeBytes;
        this.reset();
      }, reset:function() {
        var hasher = this._hasher;
        hasher.reset();
        hasher.update(this._iKey);
      }, update:function(messageUpdate) {
        this._hasher.update(messageUpdate);
        return this;
      }, finalize:function(messageUpdate) {
        var hasher = this._hasher;
        messageUpdate = hasher.finalize(messageUpdate);
        hasher.reset();
        return hasher.finalize(this._oKey.clone().concat(messageUpdate));
      }});
    })();
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$hmac.js.map
