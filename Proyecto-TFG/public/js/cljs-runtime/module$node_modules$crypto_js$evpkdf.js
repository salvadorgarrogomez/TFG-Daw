shadow$provide.module$node_modules$crypto_js$evpkdf = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$sha1"), require("module$node_modules$crypto_js$hmac")) : "function" === typeof define && define.amd ? define(["./core", "./sha1", "./hmac"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      var C_lib = CryptoJS.lib, Base = C_lib.Base, WordArray = C_lib.WordArray;
      C_lib = CryptoJS.algo;
      var EvpKDF = C_lib.EvpKDF = Base.extend({cfg:Base.extend({keySize:4, hasher:C_lib.MD5, iterations:1}), init:function(cfg) {
        this.cfg = this.cfg.extend(cfg);
      }, compute:function(password, salt) {
        var cfg = this.cfg, hasher = cfg.hasher.create(), derivedKey = WordArray.create(), derivedKeyWords = derivedKey.words, keySize = cfg.keySize;
        for (cfg = cfg.iterations; derivedKeyWords.length < keySize;) {
          block && hasher.update(block);
          var block = hasher.update(password).finalize(salt);
          hasher.reset();
          for (var i = 1; i < cfg; i++) {
            block = hasher.finalize(block), hasher.reset();
          }
          derivedKey.concat(block);
        }
        derivedKey.sigBytes = 4 * keySize;
        return derivedKey;
      }});
      CryptoJS.EvpKDF = function(password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
      };
    })();
    return CryptoJS.EvpKDF;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$evpkdf.js.map
