shadow$provide.module$node_modules$crypto_js$mode_cfb = function(global, require, module, exports) {
  (function(root, factory, undef) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core"), require("module$node_modules$crypto_js$cipher_core")) : "function" === typeof define && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    CryptoJS.mode.CFB = function() {
      function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
        var keystream;
        (keystream = this._iv) ? (keystream = keystream.slice(0), this._iv = void 0) : keystream = this._prevBlock;
        cipher.encryptBlock(keystream, 0);
        for (cipher = 0; cipher < blockSize; cipher++) {
          words[offset + cipher] ^= keystream[cipher];
        }
      }
      var CFB = CryptoJS.lib.BlockCipherMode.extend();
      CFB.Encryptor = CFB.extend({processBlock:function(words, offset) {
        var cipher = this._cipher, blockSize = cipher.blockSize;
        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
        this._prevBlock = words.slice(offset, offset + blockSize);
      }});
      CFB.Decryptor = CFB.extend({processBlock:function(words, offset) {
        var cipher = this._cipher, blockSize = cipher.blockSize, thisBlock = words.slice(offset, offset + blockSize);
        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
        this._prevBlock = thisBlock;
      }});
      return CFB;
    }();
    return CryptoJS.mode.CFB;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$mode_cfb.js.map
