shadow$provide.module$node_modules$crypto_js$enc_utf16 = function(global, require, module, exports) {
  (function(root, factory) {
    "object" === typeof exports ? module.exports = exports = factory(require("module$node_modules$crypto_js$core")) : "function" === typeof define && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(this, function(CryptoJS) {
    (function() {
      function swapEndian(word) {
        return word << 8 & 4278255360 | word >>> 8 & 16711935;
      }
      var WordArray = CryptoJS.lib.WordArray, C_enc = CryptoJS.enc;
      C_enc.Utf16 = C_enc.Utf16BE = {stringify:function(wordArray) {
        var words = wordArray.words;
        wordArray = wordArray.sigBytes;
        for (var utf16Chars = [], i = 0; i < wordArray; i += 2) {
          utf16Chars.push(String.fromCharCode(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535));
        }
        return utf16Chars.join("");
      }, parse:function(utf16Str) {
        for (var utf16StrLength = utf16Str.length, words = [], i = 0; i < utf16StrLength; i++) {
          words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
        }
        return WordArray.create(words, 2 * utf16StrLength);
      }};
      C_enc.Utf16LE = {stringify:function(wordArray) {
        var words = wordArray.words;
        wordArray = wordArray.sigBytes;
        for (var utf16Chars = [], i = 0; i < wordArray; i += 2) {
          var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
          utf16Chars.push(String.fromCharCode(codePoint));
        }
        return utf16Chars.join("");
      }, parse:function(utf16Str) {
        for (var utf16StrLength = utf16Str.length, words = [], i = 0; i < utf16StrLength; i++) {
          words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
        }
        return WordArray.create(words, 2 * utf16StrLength);
      }};
    })();
    return CryptoJS.enc.Utf16;
  });
};

//# sourceMappingURL=module$node_modules$crypto_js$enc_utf16.js.map
