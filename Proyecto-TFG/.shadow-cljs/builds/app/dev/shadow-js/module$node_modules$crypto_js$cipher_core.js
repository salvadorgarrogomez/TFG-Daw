["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/crypto-js/cipher-core.js"],"~:js","shadow$provide.module$node_modules$crypto_js$cipher_core = function(global, require, module, exports) {\n  (function(root, factory, undef) {\n    \"object\" === typeof exports ? module.exports = exports = factory(require(\"module$node_modules$crypto_js$core\"), require(\"module$node_modules$crypto_js$evpkdf\")) : \"function\" === typeof define && define.amd ? define([\"./core\", \"./evpkdf\"], factory) : factory(root.CryptoJS);\n  })(this, function(CryptoJS) {\n    CryptoJS.lib.Cipher || function(undefined) {\n      var C_lib = CryptoJS.lib, Base = C_lib.Base, WordArray = C_lib.WordArray, BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm, Base64 = CryptoJS.enc.Base64, EvpKDF = CryptoJS.algo.EvpKDF, Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({cfg:Base.extend(), createEncryptor:function(key, cfg) {\n        return this.create(this._ENC_XFORM_MODE, key, cfg);\n      }, createDecryptor:function(key, cfg) {\n        return this.create(this._DEC_XFORM_MODE, key, cfg);\n      }, init:function(xformMode, key, cfg) {\n        this.cfg = this.cfg.extend(cfg);\n        this._xformMode = xformMode;\n        this._key = key;\n        this.reset();\n      }, reset:function() {\n        BufferedBlockAlgorithm.reset.call(this);\n        this._doReset();\n      }, process:function(dataUpdate) {\n        this._append(dataUpdate);\n        return this._process();\n      }, finalize:function(dataUpdate) {\n        dataUpdate && this._append(dataUpdate);\n        return this._doFinalize();\n      }, keySize:4, ivSize:4, _ENC_XFORM_MODE:1, _DEC_XFORM_MODE:2, _createHelper:function() {\n        return function(cipher) {\n          return {encrypt:function(message, key, cfg) {\n            return (\"string\" == typeof key ? PasswordBasedCipher : SerializableCipher).encrypt(cipher, message, key, cfg);\n          }, decrypt:function(ciphertext, key, cfg) {\n            return (\"string\" == typeof key ? PasswordBasedCipher : SerializableCipher).decrypt(cipher, ciphertext, key, cfg);\n          }};\n        };\n      }()});\n      C_lib.StreamCipher = Cipher.extend({_doFinalize:function() {\n        return this._process(!0);\n      }, blockSize:1});\n      var C_mode = CryptoJS.mode = {}, BlockCipherMode = C_lib.BlockCipherMode = Base.extend({createEncryptor:function(cipher, iv) {\n        return this.Encryptor.create(cipher, iv);\n      }, createDecryptor:function(cipher, iv) {\n        return this.Decryptor.create(cipher, iv);\n      }, init:function(cipher, iv) {\n        this._cipher = cipher;\n        this._iv = iv;\n      }});\n      C_mode = C_mode.CBC = function() {\n        function xorBlock(words, offset, blockSize) {\n          var block;\n          (block = this._iv) ? this._iv = undefined : block = this._prevBlock;\n          for (var i = 0; i < blockSize; i++) {\n            words[offset + i] ^= block[i];\n          }\n        }\n        var CBC = BlockCipherMode.extend();\n        CBC.Encryptor = CBC.extend({processBlock:function(words, offset) {\n          var cipher = this._cipher, blockSize = cipher.blockSize;\n          xorBlock.call(this, words, offset, blockSize);\n          cipher.encryptBlock(words, offset);\n          this._prevBlock = words.slice(offset, offset + blockSize);\n        }});\n        CBC.Decryptor = CBC.extend({processBlock:function(words, offset) {\n          var cipher = this._cipher, blockSize = cipher.blockSize, thisBlock = words.slice(offset, offset + blockSize);\n          cipher.decryptBlock(words, offset);\n          xorBlock.call(this, words, offset, blockSize);\n          this._prevBlock = thisBlock;\n        }});\n        return CBC;\n      }();\n      var Pkcs7 = (CryptoJS.pad = {}).Pkcs7 = {pad:function(data, blockSize) {\n        blockSize *= 4;\n        blockSize -= data.sigBytes % blockSize;\n        for (var paddingWord = blockSize << 24 | blockSize << 16 | blockSize << 8 | blockSize, paddingWords = [], i = 0; i < blockSize; i += 4) {\n          paddingWords.push(paddingWord);\n        }\n        blockSize = WordArray.create(paddingWords, blockSize);\n        data.concat(blockSize);\n      }, unpad:function(data) {\n        data.sigBytes -= data.words[data.sigBytes - 1 >>> 2] & 255;\n      }};\n      C_lib.BlockCipher = Cipher.extend({cfg:Cipher.cfg.extend({mode:C_mode, padding:Pkcs7}), reset:function() {\n        Cipher.reset.call(this);\n        var modeCreator = this.cfg;\n        var iv = modeCreator.iv, mode = modeCreator.mode;\n        this._xformMode == this._ENC_XFORM_MODE ? modeCreator = mode.createEncryptor : (modeCreator = mode.createDecryptor, this._minBufferSize = 1);\n        this._mode && this._mode.__creator == modeCreator ? this._mode.init(this, iv && iv.words) : (this._mode = modeCreator.call(mode, this, iv && iv.words), this._mode.__creator = modeCreator);\n      }, _doProcessBlock:function(words, offset) {\n        this._mode.processBlock(words, offset);\n      }, _doFinalize:function() {\n        var padding = this.cfg.padding;\n        if (this._xformMode == this._ENC_XFORM_MODE) {\n          padding.pad(this._data, this.blockSize);\n          var finalProcessedBlocks = this._process(!0);\n        } else {\n          finalProcessedBlocks = this._process(!0), padding.unpad(finalProcessedBlocks);\n        }\n        return finalProcessedBlocks;\n      }, blockSize:4});\n      var CipherParams = C_lib.CipherParams = Base.extend({init:function(cipherParams) {\n        this.mixIn(cipherParams);\n      }, toString:function(formatter) {\n        return (formatter || this.formatter).stringify(this);\n      }});\n      C_mode = (CryptoJS.format = {}).OpenSSL = {stringify:function(cipherParams) {\n        var ciphertext = cipherParams.ciphertext;\n        cipherParams = cipherParams.salt;\n        return (cipherParams ? WordArray.create([1398893684, 1701076831]).concat(cipherParams).concat(ciphertext) : ciphertext).toString(Base64);\n      }, parse:function(openSSLStr) {\n        openSSLStr = Base64.parse(openSSLStr);\n        var ciphertextWords = openSSLStr.words;\n        if (1398893684 == ciphertextWords[0] && 1701076831 == ciphertextWords[1]) {\n          var salt = WordArray.create(ciphertextWords.slice(2, 4));\n          ciphertextWords.splice(0, 4);\n          openSSLStr.sigBytes -= 16;\n        }\n        return CipherParams.create({ciphertext:openSSLStr, salt});\n      }};\n      var SerializableCipher = C_lib.SerializableCipher = Base.extend({cfg:Base.extend({format:C_mode}), encrypt:function(cipher, message, key, cfg) {\n        cfg = this.cfg.extend(cfg);\n        var encryptor = cipher.createEncryptor(key, cfg);\n        message = encryptor.finalize(message);\n        encryptor = encryptor.cfg;\n        return CipherParams.create({ciphertext:message, key, iv:encryptor.iv, algorithm:cipher, mode:encryptor.mode, padding:encryptor.padding, blockSize:cipher.blockSize, formatter:cfg.format});\n      }, decrypt:function(cipher, ciphertext, key, cfg) {\n        cfg = this.cfg.extend(cfg);\n        ciphertext = this._parse(ciphertext, cfg.format);\n        return cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n      }, _parse:function(ciphertext, format) {\n        return \"string\" == typeof ciphertext ? format.parse(ciphertext, this) : ciphertext;\n      }});\n      Base = (CryptoJS.kdf = {}).OpenSSL = {execute:function(password, keySize, ivSize, salt, hasher) {\n        salt || (salt = WordArray.random(8));\n        password = hasher ? EvpKDF.create({keySize:keySize + ivSize, hasher}).compute(password, salt) : EvpKDF.create({keySize:keySize + ivSize}).compute(password, salt);\n        ivSize = WordArray.create(password.words.slice(keySize), 4 * ivSize);\n        password.sigBytes = 4 * keySize;\n        return CipherParams.create({key:password, iv:ivSize, salt});\n      }};\n      var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:Base}), encrypt:function(cipher, message, password, cfg) {\n        cfg = this.cfg.extend(cfg);\n        password = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);\n        cfg.iv = password.iv;\n        cipher = SerializableCipher.encrypt.call(this, cipher, message, password.key, cfg);\n        cipher.mixIn(password);\n        return cipher;\n      }, decrypt:function(cipher, ciphertext, password, cfg) {\n        cfg = this.cfg.extend(cfg);\n        ciphertext = this._parse(ciphertext, cfg.format);\n        password = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);\n        cfg.iv = password.iv;\n        return SerializableCipher.decrypt.call(this, cipher, ciphertext, password.key, cfg);\n      }});\n    }();\n  });\n};\n","~:source","shadow$provide[\"module$node_modules$crypto_js$cipher_core\"] = function(global,require,module,exports) {\n;(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./evpkdf\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./evpkdf\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt, hasher) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            if (!hasher) {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\t            } else {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);\n\t            }\n\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$crypto_js$core","~$shadow.js","~$module$node_modules$crypto_js$evpkdf"]],"~:properties",["^5",["iv","_key","encrypt","BlockCipherMode","ciphertext","_cipher","keySize","pad","Cipher","BlockCipher","unpad","OpenSSL","cfg","key","process","padding","_xformMode","_createHelper","toString","reset","algorithm","_minBufferSize","mode","SerializableCipher","_prevBlock","_doFinalize","ivSize","processBlock","Encryptor","blockSize","hasher","salt","sigBytes","_doProcessBlock","PasswordBasedCipher","stringify","init","Decryptor","decrypt","execute","Pkcs7","formatter","parse","createDecryptor","CipherParams","_parse","CBC","_iv","kdf","_ENC_XFORM_MODE","createEncryptor","StreamCipher","_mode","__creator","format","_DEC_XFORM_MODE","finalize"]],"~:compiled-at",1745068084554,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$crypto_js$cipher_core.js\",\n\"lineCount\":152,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/crypto-js/cipher-core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$crypto_js$cipher_core\\\"] = function(global,require,module,exports) {\\n;(function (root, factory, undef) {\\n\\tif (typeof exports === \\\"object\\\") {\\n\\t\\t// CommonJS\\n\\t\\tmodule.exports = exports = factory(require(\\\"./core\\\"), require(\\\"./evpkdf\\\"));\\n\\t}\\n\\telse if (typeof define === \\\"function\\\" && define.amd) {\\n\\t\\t// AMD\\n\\t\\tdefine([\\\"./core\\\", \\\"./evpkdf\\\"], factory);\\n\\t}\\n\\telse {\\n\\t\\t// Global (browser)\\n\\t\\tfactory(root.CryptoJS);\\n\\t}\\n}(this, function (CryptoJS) {\\n\\n\\t/**\\n\\t * Cipher core components.\\n\\t */\\n\\tCryptoJS.lib.Cipher || (function (undefined) {\\n\\t    // Shortcuts\\n\\t    var C = CryptoJS;\\n\\t    var C_lib = C.lib;\\n\\t    var Base = C_lib.Base;\\n\\t    var WordArray = C_lib.WordArray;\\n\\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\\n\\t    var C_enc = C.enc;\\n\\t    var Utf8 = C_enc.Utf8;\\n\\t    var Base64 = C_enc.Base64;\\n\\t    var C_algo = C.algo;\\n\\t    var EvpKDF = C_algo.EvpKDF;\\n\\n\\t    /**\\n\\t     * Abstract base cipher template.\\n\\t     *\\n\\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\\n\\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\\n\\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\\n\\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\\n\\t     */\\n\\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {WordArray} iv The IV to use for this operation.\\n\\t         */\\n\\t        cfg: Base.extend(),\\n\\n\\t        /**\\n\\t         * Creates this cipher in encryption mode.\\n\\t         *\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {Cipher} A cipher instance.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        createEncryptor: function (key, cfg) {\\n\\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Creates this cipher in decryption mode.\\n\\t         *\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {Cipher} A cipher instance.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        createDecryptor: function (key, cfg) {\\n\\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Initializes a newly created cipher.\\n\\t         *\\n\\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\\n\\t         */\\n\\t        init: function (xformMode, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            this.cfg = this.cfg.extend(cfg);\\n\\n\\t            // Store transform mode and key\\n\\t            this._xformMode = xformMode;\\n\\t            this._key = key;\\n\\n\\t            // Set initial values\\n\\t            this.reset();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Resets this cipher to its initial state.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     cipher.reset();\\n\\t         */\\n\\t        reset: function () {\\n\\t            // Reset data buffer\\n\\t            BufferedBlockAlgorithm.reset.call(this);\\n\\n\\t            // Perform concrete-cipher logic\\n\\t            this._doReset();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Adds data to be encrypted or decrypted.\\n\\t         *\\n\\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\\n\\t         *\\n\\t         * @return {WordArray} The data after processing.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var encrypted = cipher.process('data');\\n\\t         *     var encrypted = cipher.process(wordArray);\\n\\t         */\\n\\t        process: function (dataUpdate) {\\n\\t            // Append\\n\\t            this._append(dataUpdate);\\n\\n\\t            // Process available blocks\\n\\t            return this._process();\\n\\t        },\\n\\n\\t        /**\\n\\t         * Finalizes the encryption or decryption process.\\n\\t         * Note that the finalize operation is effectively a destructive, read-once operation.\\n\\t         *\\n\\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\\n\\t         *\\n\\t         * @return {WordArray} The data after final processing.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var encrypted = cipher.finalize();\\n\\t         *     var encrypted = cipher.finalize('data');\\n\\t         *     var encrypted = cipher.finalize(wordArray);\\n\\t         */\\n\\t        finalize: function (dataUpdate) {\\n\\t            // Final data update\\n\\t            if (dataUpdate) {\\n\\t                this._append(dataUpdate);\\n\\t            }\\n\\n\\t            // Perform concrete-cipher logic\\n\\t            var finalProcessedData = this._doFinalize();\\n\\n\\t            return finalProcessedData;\\n\\t        },\\n\\n\\t        keySize: 128/32,\\n\\n\\t        ivSize: 128/32,\\n\\n\\t        _ENC_XFORM_MODE: 1,\\n\\n\\t        _DEC_XFORM_MODE: 2,\\n\\n\\t        /**\\n\\t         * Creates shortcut functions to a cipher's object interface.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher to create a helper for.\\n\\t         *\\n\\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\\n\\t         */\\n\\t        _createHelper: (function () {\\n\\t            function selectCipherStrategy(key) {\\n\\t                if (typeof key == 'string') {\\n\\t                    return PasswordBasedCipher;\\n\\t                } else {\\n\\t                    return SerializableCipher;\\n\\t                }\\n\\t            }\\n\\n\\t            return function (cipher) {\\n\\t                return {\\n\\t                    encrypt: function (message, key, cfg) {\\n\\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\\n\\t                    },\\n\\n\\t                    decrypt: function (ciphertext, key, cfg) {\\n\\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\\n\\t                    }\\n\\t                };\\n\\t            };\\n\\t        }())\\n\\t    });\\n\\n\\t    /**\\n\\t     * Abstract base stream cipher template.\\n\\t     *\\n\\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\\n\\t     */\\n\\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\\n\\t        _doFinalize: function () {\\n\\t            // Process partial blocks\\n\\t            var finalProcessedBlocks = this._process(!!'flush');\\n\\n\\t            return finalProcessedBlocks;\\n\\t        },\\n\\n\\t        blockSize: 1\\n\\t    });\\n\\n\\t    /**\\n\\t     * Mode namespace.\\n\\t     */\\n\\t    var C_mode = C.mode = {};\\n\\n\\t    /**\\n\\t     * Abstract base block cipher mode template.\\n\\t     */\\n\\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\\n\\t        /**\\n\\t         * Creates this mode for encryption.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\\n\\t         */\\n\\t        createEncryptor: function (cipher, iv) {\\n\\t            return this.Encryptor.create(cipher, iv);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Creates this mode for decryption.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\\n\\t         */\\n\\t        createDecryptor: function (cipher, iv) {\\n\\t            return this.Decryptor.create(cipher, iv);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Initializes a newly created mode.\\n\\t         *\\n\\t         * @param {Cipher} cipher A block cipher instance.\\n\\t         * @param {Array} iv The IV words.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\\n\\t         */\\n\\t        init: function (cipher, iv) {\\n\\t            this._cipher = cipher;\\n\\t            this._iv = iv;\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Cipher Block Chaining mode.\\n\\t     */\\n\\t    var CBC = C_mode.CBC = (function () {\\n\\t        /**\\n\\t         * Abstract base CBC mode.\\n\\t         */\\n\\t        var CBC = BlockCipherMode.extend();\\n\\n\\t        /**\\n\\t         * CBC encryptor.\\n\\t         */\\n\\t        CBC.Encryptor = CBC.extend({\\n\\t            /**\\n\\t             * Processes the data block at offset.\\n\\t             *\\n\\t             * @param {Array} words The data words to operate on.\\n\\t             * @param {number} offset The offset where the block starts.\\n\\t             *\\n\\t             * @example\\n\\t             *\\n\\t             *     mode.processBlock(data.words, offset);\\n\\t             */\\n\\t            processBlock: function (words, offset) {\\n\\t                // Shortcuts\\n\\t                var cipher = this._cipher;\\n\\t                var blockSize = cipher.blockSize;\\n\\n\\t                // XOR and encrypt\\n\\t                xorBlock.call(this, words, offset, blockSize);\\n\\t                cipher.encryptBlock(words, offset);\\n\\n\\t                // Remember this block to use with next block\\n\\t                this._prevBlock = words.slice(offset, offset + blockSize);\\n\\t            }\\n\\t        });\\n\\n\\t        /**\\n\\t         * CBC decryptor.\\n\\t         */\\n\\t        CBC.Decryptor = CBC.extend({\\n\\t            /**\\n\\t             * Processes the data block at offset.\\n\\t             *\\n\\t             * @param {Array} words The data words to operate on.\\n\\t             * @param {number} offset The offset where the block starts.\\n\\t             *\\n\\t             * @example\\n\\t             *\\n\\t             *     mode.processBlock(data.words, offset);\\n\\t             */\\n\\t            processBlock: function (words, offset) {\\n\\t                // Shortcuts\\n\\t                var cipher = this._cipher;\\n\\t                var blockSize = cipher.blockSize;\\n\\n\\t                // Remember this block to use with next block\\n\\t                var thisBlock = words.slice(offset, offset + blockSize);\\n\\n\\t                // Decrypt and XOR\\n\\t                cipher.decryptBlock(words, offset);\\n\\t                xorBlock.call(this, words, offset, blockSize);\\n\\n\\t                // This block becomes the previous block\\n\\t                this._prevBlock = thisBlock;\\n\\t            }\\n\\t        });\\n\\n\\t        function xorBlock(words, offset, blockSize) {\\n\\t            var block;\\n\\n\\t            // Shortcut\\n\\t            var iv = this._iv;\\n\\n\\t            // Choose mixing block\\n\\t            if (iv) {\\n\\t                block = iv;\\n\\n\\t                // Remove IV for subsequent blocks\\n\\t                this._iv = undefined;\\n\\t            } else {\\n\\t                block = this._prevBlock;\\n\\t            }\\n\\n\\t            // XOR blocks\\n\\t            for (var i = 0; i < blockSize; i++) {\\n\\t                words[offset + i] ^= block[i];\\n\\t            }\\n\\t        }\\n\\n\\t        return CBC;\\n\\t    }());\\n\\n\\t    /**\\n\\t     * Padding namespace.\\n\\t     */\\n\\t    var C_pad = C.pad = {};\\n\\n\\t    /**\\n\\t     * PKCS #5/7 padding strategy.\\n\\t     */\\n\\t    var Pkcs7 = C_pad.Pkcs7 = {\\n\\t        /**\\n\\t         * Pads data using the algorithm defined in PKCS #5/7.\\n\\t         *\\n\\t         * @param {WordArray} data The data to pad.\\n\\t         * @param {number} blockSize The multiple that the data should be padded to.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\\n\\t         */\\n\\t        pad: function (data, blockSize) {\\n\\t            // Shortcut\\n\\t            var blockSizeBytes = blockSize * 4;\\n\\n\\t            // Count padding bytes\\n\\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\\n\\n\\t            // Create padding word\\n\\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\\n\\n\\t            // Create padding\\n\\t            var paddingWords = [];\\n\\t            for (var i = 0; i < nPaddingBytes; i += 4) {\\n\\t                paddingWords.push(paddingWord);\\n\\t            }\\n\\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\\n\\n\\t            // Add padding\\n\\t            data.concat(padding);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\\n\\t         *\\n\\t         * @param {WordArray} data The data to unpad.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\\n\\t         */\\n\\t        unpad: function (data) {\\n\\t            // Get number of padding bytes from last byte\\n\\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\\n\\n\\t            // Remove padding\\n\\t            data.sigBytes -= nPaddingBytes;\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * Abstract base block cipher template.\\n\\t     *\\n\\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\\n\\t     */\\n\\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {Mode} mode The block mode to use. Default: CBC\\n\\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\\n\\t         */\\n\\t        cfg: Cipher.cfg.extend({\\n\\t            mode: CBC,\\n\\t            padding: Pkcs7\\n\\t        }),\\n\\n\\t        reset: function () {\\n\\t            var modeCreator;\\n\\n\\t            // Reset cipher\\n\\t            Cipher.reset.call(this);\\n\\n\\t            // Shortcuts\\n\\t            var cfg = this.cfg;\\n\\t            var iv = cfg.iv;\\n\\t            var mode = cfg.mode;\\n\\n\\t            // Reset block mode\\n\\t            if (this._xformMode == this._ENC_XFORM_MODE) {\\n\\t                modeCreator = mode.createEncryptor;\\n\\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\\n\\t                modeCreator = mode.createDecryptor;\\n\\t                // Keep at least one block in the buffer for unpadding\\n\\t                this._minBufferSize = 1;\\n\\t            }\\n\\n\\t            if (this._mode && this._mode.__creator == modeCreator) {\\n\\t                this._mode.init(this, iv && iv.words);\\n\\t            } else {\\n\\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\\n\\t                this._mode.__creator = modeCreator;\\n\\t            }\\n\\t        },\\n\\n\\t        _doProcessBlock: function (words, offset) {\\n\\t            this._mode.processBlock(words, offset);\\n\\t        },\\n\\n\\t        _doFinalize: function () {\\n\\t            var finalProcessedBlocks;\\n\\n\\t            // Shortcut\\n\\t            var padding = this.cfg.padding;\\n\\n\\t            // Finalize\\n\\t            if (this._xformMode == this._ENC_XFORM_MODE) {\\n\\t                // Pad data\\n\\t                padding.pad(this._data, this.blockSize);\\n\\n\\t                // Process final blocks\\n\\t                finalProcessedBlocks = this._process(!!'flush');\\n\\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\\n\\t                // Process final blocks\\n\\t                finalProcessedBlocks = this._process(!!'flush');\\n\\n\\t                // Unpad data\\n\\t                padding.unpad(finalProcessedBlocks);\\n\\t            }\\n\\n\\t            return finalProcessedBlocks;\\n\\t        },\\n\\n\\t        blockSize: 128/32\\n\\t    });\\n\\n\\t    /**\\n\\t     * A collection of cipher parameters.\\n\\t     *\\n\\t     * @property {WordArray} ciphertext The raw ciphertext.\\n\\t     * @property {WordArray} key The key to this ciphertext.\\n\\t     * @property {WordArray} iv The IV used in the ciphering operation.\\n\\t     * @property {WordArray} salt The salt used with a key derivation function.\\n\\t     * @property {Cipher} algorithm The cipher algorithm.\\n\\t     * @property {Mode} mode The block mode used in the ciphering operation.\\n\\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\\n\\t     * @property {number} blockSize The block size of the cipher.\\n\\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\\n\\t     */\\n\\t    var CipherParams = C_lib.CipherParams = Base.extend({\\n\\t        /**\\n\\t         * Initializes a newly created cipher params object.\\n\\t         *\\n\\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\\n\\t         *         ciphertext: ciphertextWordArray,\\n\\t         *         key: keyWordArray,\\n\\t         *         iv: ivWordArray,\\n\\t         *         salt: saltWordArray,\\n\\t         *         algorithm: CryptoJS.algo.AES,\\n\\t         *         mode: CryptoJS.mode.CBC,\\n\\t         *         padding: CryptoJS.pad.PKCS7,\\n\\t         *         blockSize: 4,\\n\\t         *         formatter: CryptoJS.format.OpenSSL\\n\\t         *     });\\n\\t         */\\n\\t        init: function (cipherParams) {\\n\\t            this.mixIn(cipherParams);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts this cipher params object to a string.\\n\\t         *\\n\\t         * @param {Format} formatter (Optional) The formatting strategy to use.\\n\\t         *\\n\\t         * @return {string} The stringified cipher params.\\n\\t         *\\n\\t         * @throws Error If neither the formatter nor the default formatter is set.\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var string = cipherParams + '';\\n\\t         *     var string = cipherParams.toString();\\n\\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\\n\\t         */\\n\\t        toString: function (formatter) {\\n\\t            return (formatter || this.formatter).stringify(this);\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Format namespace.\\n\\t     */\\n\\t    var C_format = C.format = {};\\n\\n\\t    /**\\n\\t     * OpenSSL formatting strategy.\\n\\t     */\\n\\t    var OpenSSLFormatter = C_format.OpenSSL = {\\n\\t        /**\\n\\t         * Converts a cipher params object to an OpenSSL-compatible string.\\n\\t         *\\n\\t         * @param {CipherParams} cipherParams The cipher params object.\\n\\t         *\\n\\t         * @return {string} The OpenSSL-compatible string.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\\n\\t         */\\n\\t        stringify: function (cipherParams) {\\n\\t            var wordArray;\\n\\n\\t            // Shortcuts\\n\\t            var ciphertext = cipherParams.ciphertext;\\n\\t            var salt = cipherParams.salt;\\n\\n\\t            // Format\\n\\t            if (salt) {\\n\\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\\n\\t            } else {\\n\\t                wordArray = ciphertext;\\n\\t            }\\n\\n\\t            return wordArray.toString(Base64);\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts an OpenSSL-compatible string to a cipher params object.\\n\\t         *\\n\\t         * @param {string} openSSLStr The OpenSSL-compatible string.\\n\\t         *\\n\\t         * @return {CipherParams} The cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\\n\\t         */\\n\\t        parse: function (openSSLStr) {\\n\\t            var salt;\\n\\n\\t            // Parse base64\\n\\t            var ciphertext = Base64.parse(openSSLStr);\\n\\n\\t            // Shortcut\\n\\t            var ciphertextWords = ciphertext.words;\\n\\n\\t            // Test for salt\\n\\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\\n\\t                // Extract salt\\n\\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\\n\\n\\t                // Remove salt from ciphertext\\n\\t                ciphertextWords.splice(0, 4);\\n\\t                ciphertext.sigBytes -= 16;\\n\\t            }\\n\\n\\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\\n\\t     */\\n\\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\\n\\t         */\\n\\t        cfg: Base.extend({\\n\\t            format: OpenSSLFormatter\\n\\t        }),\\n\\n\\t        /**\\n\\t         * Encrypts a message.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {WordArray|string} message The message to encrypt.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        encrypt: function (cipher, message, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Encrypt\\n\\t            var encryptor = cipher.createEncryptor(key, cfg);\\n\\t            var ciphertext = encryptor.finalize(message);\\n\\n\\t            // Shortcut\\n\\t            var cipherCfg = encryptor.cfg;\\n\\n\\t            // Create and return serializable cipher params\\n\\t            return CipherParams.create({\\n\\t                ciphertext: ciphertext,\\n\\t                key: key,\\n\\t                iv: cipherCfg.iv,\\n\\t                algorithm: cipher,\\n\\t                mode: cipherCfg.mode,\\n\\t                padding: cipherCfg.padding,\\n\\t                blockSize: cipher.blockSize,\\n\\t                formatter: cfg.format\\n\\t            });\\n\\t        },\\n\\n\\t        /**\\n\\t         * Decrypts serialized ciphertext.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\\n\\t         * @param {WordArray} key The key.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {WordArray} The plaintext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        decrypt: function (cipher, ciphertext, key, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Convert string to CipherParams\\n\\t            ciphertext = this._parse(ciphertext, cfg.format);\\n\\n\\t            // Decrypt\\n\\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\\n\\n\\t            return plaintext;\\n\\t        },\\n\\n\\t        /**\\n\\t         * Converts serialized ciphertext to CipherParams,\\n\\t         * else assumed CipherParams already and returns ciphertext unchanged.\\n\\t         *\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext.\\n\\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\\n\\t         *\\n\\t         * @return {CipherParams} The unserialized ciphertext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\\n\\t         */\\n\\t        _parse: function (ciphertext, format) {\\n\\t            if (typeof ciphertext == 'string') {\\n\\t                return format.parse(ciphertext, this);\\n\\t            } else {\\n\\t                return ciphertext;\\n\\t            }\\n\\t        }\\n\\t    });\\n\\n\\t    /**\\n\\t     * Key derivation function namespace.\\n\\t     */\\n\\t    var C_kdf = C.kdf = {};\\n\\n\\t    /**\\n\\t     * OpenSSL key derivation function.\\n\\t     */\\n\\t    var OpenSSLKdf = C_kdf.OpenSSL = {\\n\\t        /**\\n\\t         * Derives a key and IV from a password.\\n\\t         *\\n\\t         * @param {string} password The password to derive from.\\n\\t         * @param {number} keySize The size in words of the key to generate.\\n\\t         * @param {number} ivSize The size in words of the IV to generate.\\n\\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\\n\\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\\n\\t         */\\n\\t        execute: function (password, keySize, ivSize, salt, hasher) {\\n\\t            // Generate random salt\\n\\t            if (!salt) {\\n\\t                salt = WordArray.random(64/8);\\n\\t            }\\n\\n\\t            // Derive key and IV\\n\\t            if (!hasher) {\\n\\t                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\\n\\t            } else {\\n\\t                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);\\n\\t            }\\n\\n\\n\\t            // Separate key and IV\\n\\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\\n\\t            key.sigBytes = keySize * 4;\\n\\n\\t            // Return params\\n\\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\\n\\t        }\\n\\t    };\\n\\n\\t    /**\\n\\t     * A serializable cipher wrapper that derives the key from a password,\\n\\t     * and returns ciphertext as a serializable cipher params object.\\n\\t     */\\n\\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\\n\\t        /**\\n\\t         * Configuration options.\\n\\t         *\\n\\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\\n\\t         */\\n\\t        cfg: SerializableCipher.cfg.extend({\\n\\t            kdf: OpenSSLKdf\\n\\t        }),\\n\\n\\t        /**\\n\\t         * Encrypts a message using a password.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {WordArray|string} message The message to encrypt.\\n\\t         * @param {string} password The password.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {CipherParams} A cipher params object.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\\n\\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        encrypt: function (cipher, message, password, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Derive key and other params\\n\\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);\\n\\n\\t            // Add IV to config\\n\\t            cfg.iv = derivedParams.iv;\\n\\n\\t            // Encrypt\\n\\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\\n\\n\\t            // Mix in derived params\\n\\t            ciphertext.mixIn(derivedParams);\\n\\n\\t            return ciphertext;\\n\\t        },\\n\\n\\t        /**\\n\\t         * Decrypts serialized ciphertext using a password.\\n\\t         *\\n\\t         * @param {Cipher} cipher The cipher algorithm to use.\\n\\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\\n\\t         * @param {string} password The password.\\n\\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\\n\\t         *\\n\\t         * @return {WordArray} The plaintext.\\n\\t         *\\n\\t         * @static\\n\\t         *\\n\\t         * @example\\n\\t         *\\n\\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\\n\\t         */\\n\\t        decrypt: function (cipher, ciphertext, password, cfg) {\\n\\t            // Apply config defaults\\n\\t            cfg = this.cfg.extend(cfg);\\n\\n\\t            // Convert string to CipherParams\\n\\t            ciphertext = this._parse(ciphertext, cfg.format);\\n\\n\\t            // Derive key and other params\\n\\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);\\n\\n\\t            // Add IV to config\\n\\t            cfg.iv = derivedParams.iv;\\n\\n\\t            // Decrypt\\n\\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\\n\\n\\t            return plaintext;\\n\\t        }\\n\\t    });\\n\\t}());\\n\\n\\n}));\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"root\",\"factory\",\"undef\",\"define\",\"amd\",\"CryptoJS\",\"lib\",\"Cipher\",\"undefined\",\"C_lib\",\"Base\",\"WordArray\",\"BufferedBlockAlgorithm\",\"Base64\",\"enc\",\"EvpKDF\",\"algo\",\"extend\",\"cfg\",\"createEncryptor\",\"key\",\"create\",\"_ENC_XFORM_MODE\",\"createDecryptor\",\"_DEC_XFORM_MODE\",\"init\",\"xformMode\",\"_xformMode\",\"_key\",\"reset\",\"call\",\"_doReset\",\"process\",\"dataUpdate\",\"_append\",\"_process\",\"finalize\",\"_doFinalize\",\"finalProcessedData\",\"keySize\",\"ivSize\",\"_createHelper\",\"cipher\",\"encrypt\",\"message\",\"PasswordBasedCipher\",\"SerializableCipher\",\"decrypt\",\"ciphertext\",\"StreamCipher\",\"finalProcessedBlocks\",\"blockSize\",\"C_mode\",\"mode\",\"BlockCipherMode\",\"iv\",\"Encryptor\",\"Decryptor\",\"_cipher\",\"_iv\",\"CBC\",\"xorBlock\",\"words\",\"offset\",\"block\",\"_prevBlock\",\"i\",\"processBlock\",\"encryptBlock\",\"slice\",\"thisBlock\",\"decryptBlock\",\"Pkcs7\",\"pad\",\"data\",\"blockSizeBytes\",\"nPaddingBytes\",\"sigBytes\",\"paddingWord\",\"paddingWords\",\"push\",\"padding\",\"concat\",\"unpad\",\"BlockCipher\",\"modeCreator\",\"_minBufferSize\",\"_mode\",\"__creator\",\"_doProcessBlock\",\"_data\",\"CipherParams\",\"cipherParams\",\"mixIn\",\"toString\",\"formatter\",\"stringify\",\"OpenSSLFormatter\",\"OpenSSL\",\"format\",\"salt\",\"wordArray\",\"parse\",\"openSSLStr\",\"ciphertextWords\",\"splice\",\"encryptor\",\"cipherCfg\",\"algorithm\",\"_parse\",\"plaintext\",\"OpenSSLKdf\",\"kdf\",\"execute\",\"password\",\"hasher\",\"random\",\"compute\",\"derivedParams\"]\n}\n"]