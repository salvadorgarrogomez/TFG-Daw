["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/module/moduleloader.js"],"~:js","goog.loadModule(function(exports) {\n  function ModuleLoader() {\n    ModuleLoader.base(this, \"constructor\");\n    this.eventHandler_ = new EventHandler(this);\n    this.registerDisposable(this.eventHandler_);\n    this.loadingModulesStatus_ = {};\n  }\n  \"use strict\";\n  goog.module(\"goog.module.ModuleLoader\");\n  const AbstractModuleLoader = goog.require(\"goog.module.AbstractModuleLoader\");\n  const BulkLoader = goog.require(\"goog.net.BulkLoader\");\n  const EventHandler = goog.require(\"goog.events.EventHandler\");\n  const EventId = goog.require(\"goog.events.EventId\");\n  const EventTarget = goog.require(\"goog.events.EventTarget\");\n  const EventType = goog.require(\"goog.net.EventType\");\n  const GoogEvent = goog.require(\"goog.events.Event\");\n  const ModuleInfo = goog.requireType(\"goog.module.ModuleInfo\");\n  const SafeScript = goog.require(\"goog.html.SafeScript\");\n  const TagName = goog.require(\"goog.dom.TagName\");\n  const Timer = goog.require(\"goog.Timer\");\n  const TrustedResourceUrl = goog.require(\"goog.html.TrustedResourceUrl\");\n  const asserts = goog.require(\"goog.asserts\");\n  const browser = goog.require(\"goog.labs.userAgent.browser\");\n  const dom = goog.require(\"goog.dom\");\n  const events = goog.require(\"goog.events\");\n  const functions = goog.require(\"goog.functions\");\n  const googArray = goog.require(\"goog.array\");\n  const jsloader = goog.require(\"goog.net.jsloader\");\n  const legacyconversions = goog.require(\"goog.html.legacyconversions\");\n  const log = goog.require(\"goog.log\");\n  const product = goog.require(\"goog.userAgent.product\");\n  const safe = goog.require(\"goog.dom.safe\");\n  const userAgent = goog.require(\"goog.userAgent\");\n  goog.inherits(ModuleLoader, EventTarget);\n  ModuleLoader.prototype.logger = log.getLogger(\"goog.module.ModuleLoader\");\n  ModuleLoader.prototype.debugMode_ = false;\n  ModuleLoader.prototype.sourceUrlInjection_ = false;\n  ModuleLoader.prototype.useScriptTags_ = false;\n  ModuleLoader.supportsSourceUrlStackTraces = function() {\n    return product.CHROME || browser.isFirefox() && browser.isVersionOrHigher(\"36\");\n  };\n  ModuleLoader.supportsSourceUrlDebugger = function() {\n    return product.CHROME || userAgent.GECKO;\n  };\n  ModuleLoader.URL_MAX_LENGTH_ = 4043;\n  ModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_ = -1;\n  ModuleLoader.createScriptElement_ = function(url) {\n    const script = dom.createElement(TagName.SCRIPT);\n    safe.setScriptSrc(script, url);\n    script.async = false;\n    return script;\n  };\n  ModuleLoader.createPreloadScriptElement_ = function(url) {\n    const link = dom.createElement(TagName.LINK);\n    safe.setLinkHrefAndRel(link, url, \"preload\");\n    link.as = \"script\";\n    const nonce = safe.getScriptNonce();\n    if (nonce) {\n      link.setAttribute(\"nonce\", nonce);\n    }\n    return link;\n  };\n  ModuleLoader.prototype.getDebugMode = function() {\n    return this.debugMode_;\n  };\n  ModuleLoader.prototype.setUseScriptTags = function(useScriptTags) {\n    this.useScriptTags_ = useScriptTags;\n  };\n  ModuleLoader.prototype.getUseScriptTags = function() {\n    return this.useScriptTags_;\n  };\n  ModuleLoader.prototype.setDebugMode = function(debugMode) {\n    this.debugMode_ = debugMode;\n  };\n  ModuleLoader.prototype.setSourceUrlInjection = function(enabled) {\n    this.sourceUrlInjection_ = enabled;\n  };\n  ModuleLoader.prototype.usingSourceUrlInjection_ = function() {\n    return this.sourceUrlInjection_ || this.getDebugMode() && ModuleLoader.supportsSourceUrlStackTraces();\n  };\n  ModuleLoader.prototype.loadModules = function(ids, moduleInfoMap, {forceReload, onError, onSuccess, onTimeout} = {}) {\n    const loadStatus = this.loadingModulesStatus_[ids] || ModuleLoader.LoadStatus.createForIds_(ids, moduleInfoMap);\n    loadStatus.loadRequested = true;\n    if (loadStatus.successFn && onSuccess) {\n      loadStatus.successFn = functions.sequence(loadStatus.successFn, onSuccess);\n    } else {\n      loadStatus.successFn = onSuccess || loadStatus.successFn;\n    }\n    loadStatus.errorFn = onError || null;\n    if (!this.loadingModulesStatus_[ids]) {\n      this.loadingModulesStatus_[ids] = loadStatus;\n      this.downloadModules_(ids);\n    } else if (this.getUseScriptTags()) {\n      this.downloadModules_(ids);\n    } else if (loadStatus.responseTexts != null) {\n      this.evaluateCode_(ids);\n    }\n  };\n  ModuleLoader.prototype.evaluateCode_ = function(moduleIds) {\n    this.dispatchEvent(new ModuleLoader.RequestSuccessEvent(moduleIds));\n    log.info(this.logger, \"evaluateCode ids:\" + moduleIds);\n    const loadStatus = this.loadingModulesStatus_[moduleIds];\n    const uris = loadStatus.requestUris;\n    const texts = loadStatus.responseTexts;\n    let error = null;\n    try {\n      if (this.usingSourceUrlInjection_()) {\n        for (let i = 0; i < uris.length; i++) {\n          const script = legacyconversions.safeScriptFromString(texts[i] + \" //# sourceURL\\x3d\" + uris[i]);\n          goog.globalEval(SafeScript.unwrapTrustedScript(script));\n        }\n      } else {\n        const script = legacyconversions.safeScriptFromString(texts.join(\"\\n\"));\n        goog.globalEval(SafeScript.unwrapTrustedScript(script));\n      }\n    } catch (e) {\n      error = e;\n      log.warning(this.logger, \"Loaded incomplete code for module(s): \" + moduleIds, e);\n    }\n    this.dispatchEvent(new ModuleLoader.EvaluateCodeEvent(moduleIds));\n    if (error) {\n      this.handleErrorHelper_(moduleIds, loadStatus.errorFn, null, error);\n    } else if (loadStatus.successFn) {\n      loadStatus.successFn();\n    }\n    delete this.loadingModulesStatus_[moduleIds];\n  };\n  ModuleLoader.prototype.handleSuccess_ = function(bulkLoader, moduleIds) {\n    log.info(this.logger, \"Code loaded for module(s): \" + moduleIds);\n    const loadStatus = this.loadingModulesStatus_[moduleIds];\n    loadStatus.responseTexts = bulkLoader.getResponseTexts();\n    if (loadStatus.loadRequested) {\n      this.evaluateCode_(moduleIds);\n    }\n    Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\n  };\n  ModuleLoader.prototype.prefetchModule = function(id, moduleInfo) {\n    if (this.getDebugMode()) {\n      return;\n    }\n    log.info(this.logger, `Prefetching module: ${id}`);\n    let loadStatus = this.loadingModulesStatus_[[id]];\n    if (loadStatus) {\n      return;\n    }\n    const moduleInfoMap = {};\n    moduleInfoMap[id] = moduleInfo;\n    loadStatus = ModuleLoader.LoadStatus.createForIds_([id], moduleInfoMap);\n    this.loadingModulesStatus_[[id]] = loadStatus;\n    if (this.getUseScriptTags()) {\n      const links = [];\n      const insertPos = document.head || document.documentElement;\n      for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\n        const link = ModuleLoader.createPreloadScriptElement_(loadStatus.trustedRequestUris[i]);\n        links.push(link);\n        insertPos.insertBefore(link, insertPos.firstChild);\n      }\n      loadStatus.successFn = () => {\n        for (let i = 0; i < links.length; i++) {\n          const link = links[i];\n          dom.removeNode(link);\n        }\n      };\n    } else {\n      this.downloadModules_([id]);\n    }\n  };\n  ModuleLoader.prototype.downloadModules_ = function(ids) {\n    const debugMode = this.getDebugMode();\n    const sourceUrlInjection = this.usingSourceUrlInjection_();\n    const useScriptTags = this.getUseScriptTags();\n    if (debugMode + sourceUrlInjection + useScriptTags > 1) {\n      const effectiveFlag = useScriptTags ? \"useScriptTags\" : debugMode && !sourceUrlInjection ? \"debug\" : \"sourceUrlInjection\";\n      log.warning(this.logger, `More than one of debugMode (set to ${debugMode}), ` + `useScriptTags (set to ${useScriptTags}), ` + `and sourceUrlInjection (set to ${sourceUrlInjection}) ` + `is enabled. Proceeding with download as if ` + `${effectiveFlag} is set to true and the rest to false.`);\n    }\n    const loadStatus = asserts.assert(this.loadingModulesStatus_[ids]);\n    if (useScriptTags) {\n      this.loadWithNonAsyncScriptTag_(loadStatus, ids);\n    } else if (debugMode && !sourceUrlInjection) {\n      jsloader.safeLoadMany(loadStatus.trustedRequestUris);\n    } else {\n      log.info(this.logger, \"downloadModules ids:\" + ids + \" uris:\" + loadStatus.requestUris);\n      const bulkLoader = new BulkLoader(loadStatus.requestUris);\n      const eventHandler = this.eventHandler_;\n      eventHandler.listen(bulkLoader, EventType.SUCCESS, goog.bind(this.handleSuccess_, this, bulkLoader, ids));\n      eventHandler.listen(bulkLoader, EventType.ERROR, goog.bind(this.handleError_, this, bulkLoader, ids));\n      bulkLoader.load();\n    }\n  };\n  ModuleLoader.prototype.loadWithNonAsyncScriptTag_ = function(loadStatus, ids) {\n    log.info(this.logger, `Loading initiated for: ${ids}`);\n    if (loadStatus.trustedRequestUris.length == 0) {\n      if (loadStatus.successFn) {\n        loadStatus.successFn();\n        return;\n      }\n    }\n    let lastScript = null;\n    const insertPos = document.head || document.documentElement;\n    for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\n      const url = loadStatus.trustedRequestUris[i];\n      const urlLength = loadStatus.requestUris[i].length;\n      asserts.assert(urlLength <= ModuleLoader.URL_MAX_LENGTH_, `Module url length is ${urlLength}, which is greater than limit of ` + `${ModuleLoader.URL_MAX_LENGTH_}. This should never ` + `happen.`);\n      const scriptElement = ModuleLoader.createScriptElement_(url);\n      scriptElement.onload = () => {\n        scriptElement.onload = null;\n        scriptElement.onerror = null;\n        dom.removeNode(scriptElement);\n        if (scriptElement == lastScript) {\n          log.info(this.logger, `Loading complete for: ${ids}`);\n          lastScript = null;\n          if (loadStatus.successFn) {\n            loadStatus.successFn();\n          }\n        }\n      };\n      scriptElement.onerror = () => {\n        log.error(this.logger, `Network error when loading module(s): ${ids}`);\n        scriptElement.onload = null;\n        scriptElement.onerror = null;\n        dom.removeNode(scriptElement);\n        this.handleErrorHelper_(ids, loadStatus.errorFn, ModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_);\n        if (lastScript == scriptElement) {\n          lastScript = null;\n        } else {\n          log.error(this.logger, `Dependent requests were made in parallel with failed request ` + `for module(s) \"${ids}\". Non-recoverable out-of-order ` + `execution may occur.`);\n        }\n      };\n      lastScript = scriptElement;\n      insertPos.insertBefore(scriptElement, insertPos.firstChild);\n    }\n  };\n  ModuleLoader.prototype.handleError_ = function(bulkLoader, moduleIds, event) {\n    const loadStatus = this.loadingModulesStatus_[moduleIds];\n    if (loadStatus) {\n      delete this.loadingModulesStatus_[moduleIds];\n      this.handleErrorHelper_(moduleIds, loadStatus.errorFn, event.status);\n    }\n    Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\n  };\n  ModuleLoader.prototype.handleErrorHelper_ = function(moduleIds, errorFn, status, opt_error) {\n    this.dispatchEvent(new ModuleLoader.RequestErrorEvent(moduleIds, status, opt_error));\n    log.warning(this.logger, \"Request failed for module(s): \" + moduleIds);\n    if (errorFn) {\n      errorFn(status);\n    }\n  };\n  ModuleLoader.EventType = {EVALUATE_CODE:new EventId(events.getUniqueId(\"evaluateCode\")), REQUEST_SUCCESS:new EventId(events.getUniqueId(\"requestSuccess\")), REQUEST_ERROR:new EventId(events.getUniqueId(\"requestError\"))};\n  ModuleLoader.EvaluateCodeEvent = function(moduleIds) {\n    ModuleLoader.EvaluateCodeEvent.base(this, \"constructor\", ModuleLoader.EventType.EVALUATE_CODE);\n    this.moduleIds = moduleIds;\n  };\n  goog.inherits(ModuleLoader.EvaluateCodeEvent, GoogEvent);\n  ModuleLoader.RequestSuccessEvent = function(moduleIds) {\n    ModuleLoader.RequestSuccessEvent.base(this, \"constructor\", ModuleLoader.EventType.REQUEST_SUCCESS);\n    this.moduleIds = moduleIds;\n  };\n  goog.inherits(ModuleLoader.RequestSuccessEvent, GoogEvent);\n  ModuleLoader.RequestErrorEvent = function(moduleIds, status, opt_error) {\n    ModuleLoader.RequestErrorEvent.base(this, \"constructor\", ModuleLoader.EventType.REQUEST_ERROR);\n    this.moduleIds = moduleIds;\n    this.status = status;\n    this.error = opt_error || null;\n  };\n  goog.inherits(ModuleLoader.RequestErrorEvent, GoogEvent);\n  ModuleLoader.LoadStatus = function(trustedRequestUris) {\n    this.requestUris = trustedRequestUris.map(TrustedResourceUrl.unwrap);\n    this.trustedRequestUris = trustedRequestUris;\n    this.responseTexts = null;\n    this.loadRequested = false;\n    this.successFn = null;\n    this.errorFn = null;\n  };\n  ModuleLoader.LoadStatus.createForIds_ = function(ids, moduleInfoMap) {\n    if (!ids) {\n      return new ModuleLoader.LoadStatus([]);\n    }\n    const trustedRequestUris = [];\n    for (let i = 0; i < ids.length; i++) {\n      googArray.extend(trustedRequestUris, moduleInfoMap[ids[i]].getUris());\n    }\n    return new ModuleLoader.LoadStatus(trustedRequestUris);\n  };\n  exports = ModuleLoader;\n  return exports;\n});\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The module loader for loading modules across the network.\n *\n * Browsers do not guarantee that scripts appended to the document\n * are executed in the order they are added. For production mode, we use\n * XHRs to load scripts, because they do not have this problem and they\n * have superior mechanisms for handling failure. However, XHR-evaled\n * scripts are harder to debug.\n *\n * In debugging mode, we use normal script tags. In order to make this work,\n * we load the scripts in serial: we do not execute script B to the document\n * until we are certain that script A is finished loading.\n */\n\ngoog.module('goog.module.ModuleLoader');\n\nconst AbstractModuleLoader = goog.require('goog.module.AbstractModuleLoader');\nconst BulkLoader = goog.require('goog.net.BulkLoader');\nconst EventHandler = goog.require('goog.events.EventHandler');\nconst EventId = goog.require('goog.events.EventId');\nconst EventTarget = goog.require('goog.events.EventTarget');\nconst EventType = goog.require('goog.net.EventType');\nconst GoogEvent = goog.require('goog.events.Event');\nconst ModuleInfo = goog.requireType('goog.module.ModuleInfo');\nconst SafeScript = goog.require('goog.html.SafeScript');\nconst TagName = goog.require('goog.dom.TagName');\nconst Timer = goog.require('goog.Timer');\nconst TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');\nconst asserts = goog.require('goog.asserts');\nconst browser = goog.require('goog.labs.userAgent.browser');\nconst dom = goog.require('goog.dom');\nconst events = goog.require('goog.events');\nconst functions = goog.require('goog.functions');\nconst googArray = goog.require('goog.array');\nconst jsloader = goog.require('goog.net.jsloader');\nconst legacyconversions = goog.require('goog.html.legacyconversions');\nconst log = goog.require('goog.log');\nconst product = goog.require('goog.userAgent.product');\nconst safe = goog.require('goog.dom.safe');\nconst userAgent = goog.require('goog.userAgent');\n\n/**\n * A class that loads JavaScript modules.\n * @constructor\n * @extends {EventTarget}\n * @implements {AbstractModuleLoader}\n */\nfunction ModuleLoader() {\n  ModuleLoader.base(this, 'constructor');\n\n  /**\n   * Event handler for managing handling events.\n   * @type {!EventHandler<!ModuleLoader>}\n   * @private\n   */\n  this.eventHandler_ = new EventHandler(this);\n  this.registerDisposable(this.eventHandler_);\n\n  /**\n   * A map from module IDs to ModuleLoader.LoadStatus.\n   * @type {!Object<!Array<string>, !ModuleLoader.LoadStatus>}\n   * @private\n   */\n  this.loadingModulesStatus_ = {};\n}\ngoog.inherits(ModuleLoader, EventTarget);\n\n\n/**\n * A logger.\n * @type {?log.Logger}\n * @protected\n */\nModuleLoader.prototype.logger = log.getLogger('goog.module.ModuleLoader');\n\n\n/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */\nModuleLoader.prototype.debugMode_ = false;\n\n\n/**\n * Whether source url injection is enabled.\n * @type {boolean}\n * @private\n */\nModuleLoader.prototype.sourceUrlInjection_ = false;\n\n\n/**\n * Whether to load modules with non-async script tags.\n * @type {boolean}\n * @private\n */\nModuleLoader.prototype.useScriptTags_ = false;\n\n\n/**\n * @return {boolean} Whether sourceURL affects stack traces.\n */\nModuleLoader.supportsSourceUrlStackTraces = function() {\n  return product.CHROME ||\n      (browser.isFirefox() && browser.isVersionOrHigher('36'));\n};\n\n\n/**\n * @return {boolean} Whether sourceURL affects the debugger.\n */\nModuleLoader.supportsSourceUrlDebugger = function() {\n  return product.CHROME || userAgent.GECKO;\n};\n\n\n/**\n * URLs have a browser-dependent max character limit. IE9-IE11 are the lowest\n * common denominators for what we support - with a limit of 4043:\n * https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers#31250734\n * If the URL constructed by the loader exceeds this limit, we will try to split\n * it into multiple requests.\n * TODO(user): Make this configurable since not all users care about IE.\n * @const {number}\n * @private\n */\nModuleLoader.URL_MAX_LENGTH_ = 4043;\n\n\n/**\n * Error code for javascript syntax and network errors.\n * TODO(user): Detect more accurate error info.\n * @const {number}\n * @private\n */\nModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_ = -1;\n\n\n\n/**\n * @param {!TrustedResourceUrl} url The url to be loaded.\n * @return {!HTMLScriptElement}\n * @private\n */\nModuleLoader.createScriptElement_ = function(url) {\n  const script = dom.createElement(TagName.SCRIPT);\n  safe.setScriptSrc(script, url);\n\n  // Set scriptElt.async = false to guarantee\n  // that scripts are loaded in parallel but executed in the insertion order.\n  // For more details, check\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n  script.async = false;\n  return script;\n};\n\n\n/**\n * @param {!TrustedResourceUrl} url The url to be pre-loaded.\n * @return {!HTMLLinkElement}\n * @private\n */\nModuleLoader.createPreloadScriptElement_ = function(url) {\n  const link = dom.createElement(TagName.LINK);\n  safe.setLinkHrefAndRel(link, url, 'preload');\n  link.as = 'script';\n\n  // If CSP nonces are used, propagate them to dynamically created scripts.\n  // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n  const nonce = safe.getScriptNonce();\n  if (nonce) {\n    link.setAttribute('nonce', nonce);\n  }\n\n  return link;\n};\n\n\n/**\n * Gets the debug mode for the loader.\n * @return {boolean} Whether the debug mode is enabled.\n */\nModuleLoader.prototype.getDebugMode = function() {\n  return this.debugMode_;\n};\n\n\n/**\n * @param {boolean} useScriptTags Whether or not to use script tags\n *     (with async=false) for loading.\n */\nModuleLoader.prototype.setUseScriptTags = function(useScriptTags) {\n  this.useScriptTags_ = useScriptTags;\n};\n\n\n/**\n * Gets whether we're using non-async script tags for loading.\n * @return {boolean} Whether or not we're using non-async script tags for\n *     loading.\n */\nModuleLoader.prototype.getUseScriptTags = function() {\n  return this.useScriptTags_;\n};\n\n\n/**\n * Sets whether we're using non-async script tags for loading.\n * @param {boolean} debugMode Whether the debug mode is enabled.\n */\nModuleLoader.prototype.setDebugMode = function(debugMode) {\n  this.debugMode_ = debugMode;\n};\n\n\n/**\n * When enabled, we will add a sourceURL comment to the end of all scripts\n * to mark their origin.\n *\n * On WebKit, stack traces will reflect the sourceURL comment, so this is\n * useful for debugging webkit stack traces in production.\n *\n * Notice that in debug mode, we will use source url injection + eval rather\n * then appending script nodes to the DOM, because the scripts will load far\n * faster.  (Appending script nodes is very slow, because we can't parallelize\n * the downloading and evaling of the script).\n *\n * The cost of appending sourceURL information is negligible when compared to\n * the cost of evaling the script. Almost all clients will want this on.\n *\n * TODO(nicksantos): Turn this on by default. We may want to turn this off\n * for clients that inject their own sourceURL.\n *\n * @param {boolean} enabled Whether source url injection is enabled.\n */\nModuleLoader.prototype.setSourceUrlInjection = function(enabled) {\n  this.sourceUrlInjection_ = enabled;\n};\n\n\n/**\n * @return {boolean} Whether we're using source url injection.\n * @private\n */\nModuleLoader.prototype.usingSourceUrlInjection_ = function() {\n  return this.sourceUrlInjection_ ||\n      (this.getDebugMode() && ModuleLoader.supportsSourceUrlStackTraces());\n};\n\n\n/** @override */\nModuleLoader.prototype.loadModules = function(\n    ids, moduleInfoMap, {forceReload, onError, onSuccess, onTimeout} = {}) {\n  const loadStatus = this.loadingModulesStatus_[ids] ||\n      ModuleLoader.LoadStatus.createForIds_(ids, moduleInfoMap);\n  loadStatus.loadRequested = true;\n  if (loadStatus.successFn && onSuccess) {\n    // If there already exists a success function, chain it before the passed\n    // success functon.\n    loadStatus.successFn = functions.sequence(loadStatus.successFn, onSuccess);\n  } else {\n    loadStatus.successFn = onSuccess || loadStatus.successFn;\n  }\n  loadStatus.errorFn = onError || null;\n\n  if (!this.loadingModulesStatus_[ids]) {\n    // Modules were not prefetched.\n    this.loadingModulesStatus_[ids] = loadStatus;\n    this.downloadModules_(ids);\n    // TODO(user): Need to handle timeouts in the module loading code.\n  } else if (this.getUseScriptTags()) {\n    // We started prefetching but we used <link rel=\"preload\".../> tags, so we\n    // rely on the browser to reconcile the (existing) prefetch request and the\n    // script tag we're about to insert.\n    this.downloadModules_(ids);\n  } else if (loadStatus.responseTexts != null) {\n    // Modules prefetch is complete.\n    this.evaluateCode_(ids);\n  }\n  // Otherwise modules prefetch is in progress, and these modules will be\n  // executed after the prefetch is complete.\n};\n\n\n/**\n * Evaluate the JS code.\n * @param {!Array<string>} moduleIds The module ids.\n * @private\n */\nModuleLoader.prototype.evaluateCode_ = function(moduleIds) {\n  this.dispatchEvent(new ModuleLoader.RequestSuccessEvent(moduleIds));\n\n  log.info(this.logger, 'evaluateCode ids:' + moduleIds);\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\n  const uris = loadStatus.requestUris;\n  const texts = loadStatus.responseTexts;\n  let error = null;\n  try {\n    if (this.usingSourceUrlInjection_()) {\n      for (let i = 0; i < uris.length; i++) {\n        const script = legacyconversions.safeScriptFromString(\n            texts[i] + ' //# sourceURL=' + uris[i]);\n        goog.globalEval(SafeScript.unwrapTrustedScript(script));\n      }\n    } else {\n      const script = legacyconversions.safeScriptFromString(texts.join('\\n'));\n      goog.globalEval(SafeScript.unwrapTrustedScript(script));\n    }\n  } catch (e) {\n    error = e;\n    // TODO(user): Consider throwing an exception here.\n    log.warning(\n        this.logger, 'Loaded incomplete code for module(s): ' + moduleIds, e);\n  }\n\n  this.dispatchEvent(new ModuleLoader.EvaluateCodeEvent(moduleIds));\n\n  if (error) {\n    this.handleErrorHelper_(\n        moduleIds, loadStatus.errorFn, null /* status */, error);\n  } else if (loadStatus.successFn) {\n    loadStatus.successFn();\n  }\n  delete this.loadingModulesStatus_[moduleIds];\n};\n\n\n/**\n * Handles a successful response to a request for prefetch or load one or more\n * modules.\n *\n * @param {!BulkLoader} bulkLoader The bulk loader.\n * @param {!Array<string>} moduleIds The ids of the modules requested.\n * @private\n */\nModuleLoader.prototype.handleSuccess_ = function(bulkLoader, moduleIds) {\n  log.info(this.logger, 'Code loaded for module(s): ' + moduleIds);\n\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\n  loadStatus.responseTexts = bulkLoader.getResponseTexts();\n\n  if (loadStatus.loadRequested) {\n    this.evaluateCode_(moduleIds);\n  }\n\n  // NOTE: A bulk loader instance is used for loading a set of module ids.\n  // Once these modules have been loaded successfully or in error the bulk\n  // loader should be disposed as it is not needed anymore. A new bulk loader\n  // is instantiated for any new modules to be loaded. The dispose is called\n  // on a timer so that the bulkloader has a chance to release its\n  // objects.\n  Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\n};\n\n\n/** @override */\nModuleLoader.prototype.prefetchModule = function(id, moduleInfo) {\n  // Do not prefetch in debug mode\n  if (this.getDebugMode()) {\n    return;\n  }\n  log.info(this.logger, `Prefetching module: ${id}`);\n  let loadStatus = this.loadingModulesStatus_[[id]];\n  if (loadStatus) {\n    return;\n  }\n  const moduleInfoMap = {};\n  moduleInfoMap[id] = moduleInfo;\n  loadStatus = ModuleLoader.LoadStatus.createForIds_([id], moduleInfoMap);\n  this.loadingModulesStatus_[[id]] = loadStatus;\n  if (this.getUseScriptTags()) {\n    const links = [];\n    const insertPos = document.head || document.documentElement;\n    for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\n      const link = ModuleLoader.createPreloadScriptElement_(\n          loadStatus.trustedRequestUris[i]);\n      links.push(link);\n      insertPos.insertBefore(link, insertPos.firstChild);\n    }\n    loadStatus.successFn = () => {\n      for (let i = 0; i < links.length; i++) {\n        const link = links[i];\n        dom.removeNode(link);\n      }\n    };\n  } else {\n    this.downloadModules_([id]);\n  }\n};\n\n\n/**\n * Downloads a list of JavaScript modules.\n *\n * @param {!Array<string>} ids The module ids in dependency order.\n * @private\n */\nModuleLoader.prototype.downloadModules_ = function(ids) {\n  const debugMode = this.getDebugMode();\n  const sourceUrlInjection = this.usingSourceUrlInjection_();\n  const useScriptTags = this.getUseScriptTags();\n  if ((debugMode + sourceUrlInjection + useScriptTags) > 1) {\n    const effectiveFlag = useScriptTags ?\n        'useScriptTags' :\n        (debugMode && !sourceUrlInjection) ? 'debug' : 'sourceUrlInjection';\n    log.warning(\n        this.logger,\n        `More than one of debugMode (set to ${debugMode}), ` +\n            `useScriptTags (set to ${useScriptTags}), ` +\n            `and sourceUrlInjection (set to ${sourceUrlInjection}) ` +\n            `is enabled. Proceeding with download as if ` +\n            `${effectiveFlag} is set to true and the rest to false.`);\n  }\n  const loadStatus = asserts.assert(this.loadingModulesStatus_[ids]);\n\n  if (useScriptTags) {\n    this.loadWithNonAsyncScriptTag_(loadStatus, ids);\n  } else if (debugMode && !sourceUrlInjection) {\n    // In debug mode use <script> tags rather than XHRs to load the files.\n    // This makes it possible to debug and inspect stack traces more easily.\n    // It's also possible to use it to load JavaScript files that are hosted on\n    // another domain.\n    // The scripts need to load serially, so this is much slower than parallel\n    // script loads with source url injection.\n    jsloader.safeLoadMany(loadStatus.trustedRequestUris);\n  } else {\n    log.info(\n        this.logger,\n        'downloadModules ids:' + ids + ' uris:' + loadStatus.requestUris);\n\n    const bulkLoader = new BulkLoader(loadStatus.requestUris);\n\n    const eventHandler = this.eventHandler_;\n    eventHandler.listen(\n        bulkLoader, EventType.SUCCESS,\n        goog.bind(this.handleSuccess_, this, bulkLoader, ids));\n    eventHandler.listen(\n        bulkLoader, EventType.ERROR,\n        goog.bind(this.handleError_, this, bulkLoader, ids));\n    bulkLoader.load();\n  }\n};\n\n\n/**\n * Downloads a list of script URIS using <script async=false.../>, which\n * guarantees executuion order.\n * @param {!ModuleLoader.LoadStatus} loadStatus The load status\n *     object for this module-load.\n *  @param {!Array<string>} ids The module ids in dependency order.\n * @private\n */\nModuleLoader.prototype.loadWithNonAsyncScriptTag_ = function(loadStatus, ids) {\n  log.info(this.logger, `Loading initiated for: ${ids}`);\n  if (loadStatus.trustedRequestUris.length == 0) {\n    if (loadStatus.successFn) {\n      loadStatus.successFn();\n      return;\n    }\n  }\n\n  // We'll execute the success callback when the last script enqueed reaches\n  // onLoad.\n  let lastScript = null;\n  const insertPos = document.head || document.documentElement;\n\n  for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\n    const url = loadStatus.trustedRequestUris[i];\n    const urlLength = loadStatus.requestUris[i].length;\n    asserts.assert(\n        urlLength <= ModuleLoader.URL_MAX_LENGTH_,\n        `Module url length is ${urlLength}, which is greater than limit of ` +\n            `${ModuleLoader.URL_MAX_LENGTH_}. This should never ` +\n            `happen.`);\n\n    const scriptElement = ModuleLoader.createScriptElement_(url);\n\n    scriptElement.onload = () => {\n      scriptElement.onload = null;\n      scriptElement.onerror = null;\n      dom.removeNode(scriptElement);\n      if (scriptElement == lastScript) {\n        log.info(this.logger, `Loading complete for: ${ids}`);\n        lastScript = null;\n        if (loadStatus.successFn) {\n          loadStatus.successFn();\n        }\n      }\n    };\n\n    scriptElement.onerror = () => {\n      log.error(this.logger, `Network error when loading module(s): ${ids}`);\n      scriptElement.onload = null;\n      scriptElement.onerror = null;\n      dom.removeNode(scriptElement);\n      this.handleErrorHelper_(\n          ids, loadStatus.errorFn, ModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_);\n      if (lastScript == scriptElement) {\n        lastScript = null;\n      } else {\n        log.error(\n            this.logger,\n            `Dependent requests were made in parallel with failed request ` +\n                `for module(s) \"${ids}\". Non-recoverable out-of-order ` +\n                `execution may occur.`);\n      }\n    };\n    lastScript = scriptElement;\n    insertPos.insertBefore(scriptElement, insertPos.firstChild);\n  }\n};\n\n\n/**\n * Handles an error during a request for one or more modules.\n * @param {!BulkLoader} bulkLoader The bulk loader.\n * @param {!Array<string>} moduleIds The ids of the modules requested.\n * @param {!BulkLoader.LoadErrorEvent} event The load error event.\n * @private\n */\nModuleLoader.prototype.handleError_ = function(bulkLoader, moduleIds, event) {\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\n  // The bulk loader doesn't cancel other requests when a request fails. We will\n  // delete the loadStatus in the first failure, so it will be undefined in\n  // subsequent errors.\n  if (loadStatus) {\n    delete this.loadingModulesStatus_[moduleIds];\n    this.handleErrorHelper_(moduleIds, loadStatus.errorFn, event.status);\n  }\n\n  // NOTE: A bulk loader instance is used for loading a set of module ids. Once\n  // these modules have been loaded successfully or in error the bulk loader\n  // should be disposed as it is not needed anymore. A new bulk loader is\n  // instantiated for any new modules to be loaded. The dispose is called\n  // on another thread so that the bulkloader has a chance to release its\n  // objects.\n  Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\n};\n\n\n/**\n * Handles an error during a request for one or more modules.\n * @param {!Array<string>} moduleIds The ids of the modules requested.\n * @param {?function(?number)} errorFn The function to call on failure.\n * @param {?number} status The response status.\n * @param {!Error=} opt_error The error encountered, if available.\n * @private\n */\nModuleLoader.prototype.handleErrorHelper_ = function(\n    moduleIds, errorFn, status, opt_error) {\n  this.dispatchEvent(\n      new ModuleLoader.RequestErrorEvent(moduleIds, status, opt_error));\n\n  log.warning(this.logger, 'Request failed for module(s): ' + moduleIds);\n\n  if (errorFn) {\n    errorFn(status);\n  }\n};\n\n\n/**\n * Events dispatched by the ModuleLoader.\n * @const\n */\nModuleLoader.EventType = {\n  /**\n   * @const {!EventId<\n   *     !ModuleLoader.EvaluateCodeEvent>} Called after the code for\n   *     a module is evaluated.\n   */\n  EVALUATE_CODE: new EventId(events.getUniqueId('evaluateCode')),\n\n  /**\n   * @const {!EventId<\n   *     !ModuleLoader.RequestSuccessEvent>} Called when the\n   *     BulkLoader finishes successfully.\n   */\n  REQUEST_SUCCESS: new EventId(events.getUniqueId('requestSuccess')),\n\n  /**\n   * @const {!EventId<\n   *     !ModuleLoader.RequestErrorEvent>} Called when the\n   *     BulkLoader fails, or code loading fails.\n   */\n  REQUEST_ERROR: new EventId(events.getUniqueId('requestError'))\n};\n\n\n\n/**\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\n * @constructor\n * @extends {GoogEvent}\n * @final\n * @protected\n */\nModuleLoader.EvaluateCodeEvent = function(moduleIds) {\n  ModuleLoader.EvaluateCodeEvent.base(\n      this, 'constructor', ModuleLoader.EventType.EVALUATE_CODE);\n\n  /**\n   * @type {!Array<string>}\n   */\n  this.moduleIds = moduleIds;\n};\ngoog.inherits(ModuleLoader.EvaluateCodeEvent, GoogEvent);\n\n\n\n/**\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\n * @constructor\n * @extends {GoogEvent}\n * @final\n * @protected\n */\nModuleLoader.RequestSuccessEvent = function(moduleIds) {\n  ModuleLoader.RequestSuccessEvent.base(\n      this, 'constructor', ModuleLoader.EventType.REQUEST_SUCCESS);\n\n  /**\n   * @type {!Array<string>}\n   */\n  this.moduleIds = moduleIds;\n};\ngoog.inherits(ModuleLoader.RequestSuccessEvent, GoogEvent);\n\n\n\n/**\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\n * @param {?number} status The response status.\n * @param {!Error=} opt_error The error encountered, if available.\n * @constructor\n * @extends {GoogEvent}\n * @final\n * @protected\n */\nModuleLoader.RequestErrorEvent = function(moduleIds, status, opt_error) {\n  ModuleLoader.RequestErrorEvent.base(\n      this, 'constructor', ModuleLoader.EventType.REQUEST_ERROR);\n\n  /**\n   * @type {?Array<string>}\n   */\n  this.moduleIds = moduleIds;\n\n  /** @type {?number} */\n  this.status = status;\n\n  /** @type {?Error} */\n  this.error = opt_error || null;\n};\ngoog.inherits(ModuleLoader.RequestErrorEvent, GoogEvent);\n\n\n\n/**\n * A class that keeps the state of the module during the loading process. It is\n * used to save loading information between modules download and evaluation.\n *  @param {!Array<!TrustedResourceUrl>} trustedRequestUris the uris\n containing the modules implementing ids.\n\n * @constructor\n * @final\n */\nModuleLoader.LoadStatus = function(trustedRequestUris) {\n  /**\n   * The request uris.\n   * @final {!Array<string>}\n   */\n  this.requestUris = trustedRequestUris.map(TrustedResourceUrl.unwrap);\n\n  /**\n   * A TrustedResourceUrl version of `this.requestUris`\n   * @final {!Array<!TrustedResourceUrl>}\n   */\n  this.trustedRequestUris = trustedRequestUris;\n\n  /**\n   * The response texts.\n   * @type {?Array<string>}\n   */\n  this.responseTexts = null;\n\n  /**\n   * Whether loadModules was called for the set of modules referred by this\n   * status.\n   * @type {boolean}\n   */\n  this.loadRequested = false;\n\n  /**\n   * Success callback.\n   * @type {?function()}\n   */\n  this.successFn = null;\n\n  /**\n   * Error callback.\n   * @type {?function(?number)}\n   */\n  this.errorFn = null;\n};\n\n\n/**\n * Creates a `LoadStatus` object for tracking state during the loading of the\n * modules indexed in `ids`.\n *\n * @param {?Array<string>} ids the ids for this module load in dependency\n *   order.\n * @param {!Object<string, !ModuleInfo>} moduleInfoMap A mapping\n *     from module id to ModuleInfo object.\n * @return {!ModuleLoader.LoadStatus}\n * @private\n */\nModuleLoader.LoadStatus.createForIds_ = function(ids, moduleInfoMap) {\n  if (!ids) {\n    return new ModuleLoader.LoadStatus([]);\n  }\n  const trustedRequestUris = [];\n  for (let i = 0; i < ids.length; i++) {\n    googArray.extend(trustedRequestUris, moduleInfoMap[ids[i]].getUris());\n  }\n  return new ModuleLoader.LoadStatus(trustedRequestUris);\n};\n\n\nexports = ModuleLoader;\n","~:compiled-at",1743408368441,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.module.moduleloader.js\",\n\"lineCount\":287,\n\"mappings\":\"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\",\n\"sources\":[\"goog/module/moduleloader.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview The module loader for loading modules across the network.\\n *\\n * Browsers do not guarantee that scripts appended to the document\\n * are executed in the order they are added. For production mode, we use\\n * XHRs to load scripts, because they do not have this problem and they\\n * have superior mechanisms for handling failure. However, XHR-evaled\\n * scripts are harder to debug.\\n *\\n * In debugging mode, we use normal script tags. In order to make this work,\\n * we load the scripts in serial: we do not execute script B to the document\\n * until we are certain that script A is finished loading.\\n */\\n\\ngoog.module('goog.module.ModuleLoader');\\n\\nconst AbstractModuleLoader = goog.require('goog.module.AbstractModuleLoader');\\nconst BulkLoader = goog.require('goog.net.BulkLoader');\\nconst EventHandler = goog.require('goog.events.EventHandler');\\nconst EventId = goog.require('goog.events.EventId');\\nconst EventTarget = goog.require('goog.events.EventTarget');\\nconst EventType = goog.require('goog.net.EventType');\\nconst GoogEvent = goog.require('goog.events.Event');\\nconst ModuleInfo = goog.requireType('goog.module.ModuleInfo');\\nconst SafeScript = goog.require('goog.html.SafeScript');\\nconst TagName = goog.require('goog.dom.TagName');\\nconst Timer = goog.require('goog.Timer');\\nconst TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');\\nconst asserts = goog.require('goog.asserts');\\nconst browser = goog.require('goog.labs.userAgent.browser');\\nconst dom = goog.require('goog.dom');\\nconst events = goog.require('goog.events');\\nconst functions = goog.require('goog.functions');\\nconst googArray = goog.require('goog.array');\\nconst jsloader = goog.require('goog.net.jsloader');\\nconst legacyconversions = goog.require('goog.html.legacyconversions');\\nconst log = goog.require('goog.log');\\nconst product = goog.require('goog.userAgent.product');\\nconst safe = goog.require('goog.dom.safe');\\nconst userAgent = goog.require('goog.userAgent');\\n\\n/**\\n * A class that loads JavaScript modules.\\n * @constructor\\n * @extends {EventTarget}\\n * @implements {AbstractModuleLoader}\\n */\\nfunction ModuleLoader() {\\n  ModuleLoader.base(this, 'constructor');\\n\\n  /**\\n   * Event handler for managing handling events.\\n   * @type {!EventHandler<!ModuleLoader>}\\n   * @private\\n   */\\n  this.eventHandler_ = new EventHandler(this);\\n  this.registerDisposable(this.eventHandler_);\\n\\n  /**\\n   * A map from module IDs to ModuleLoader.LoadStatus.\\n   * @type {!Object<!Array<string>, !ModuleLoader.LoadStatus>}\\n   * @private\\n   */\\n  this.loadingModulesStatus_ = {};\\n}\\ngoog.inherits(ModuleLoader, EventTarget);\\n\\n\\n/**\\n * A logger.\\n * @type {?log.Logger}\\n * @protected\\n */\\nModuleLoader.prototype.logger = log.getLogger('goog.module.ModuleLoader');\\n\\n\\n/**\\n * Whether debug mode is enabled.\\n * @type {boolean}\\n * @private\\n */\\nModuleLoader.prototype.debugMode_ = false;\\n\\n\\n/**\\n * Whether source url injection is enabled.\\n * @type {boolean}\\n * @private\\n */\\nModuleLoader.prototype.sourceUrlInjection_ = false;\\n\\n\\n/**\\n * Whether to load modules with non-async script tags.\\n * @type {boolean}\\n * @private\\n */\\nModuleLoader.prototype.useScriptTags_ = false;\\n\\n\\n/**\\n * @return {boolean} Whether sourceURL affects stack traces.\\n */\\nModuleLoader.supportsSourceUrlStackTraces = function() {\\n  return product.CHROME ||\\n      (browser.isFirefox() && browser.isVersionOrHigher('36'));\\n};\\n\\n\\n/**\\n * @return {boolean} Whether sourceURL affects the debugger.\\n */\\nModuleLoader.supportsSourceUrlDebugger = function() {\\n  return product.CHROME || userAgent.GECKO;\\n};\\n\\n\\n/**\\n * URLs have a browser-dependent max character limit. IE9-IE11 are the lowest\\n * common denominators for what we support - with a limit of 4043:\\n * https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers#31250734\\n * If the URL constructed by the loader exceeds this limit, we will try to split\\n * it into multiple requests.\\n * TODO(user): Make this configurable since not all users care about IE.\\n * @const {number}\\n * @private\\n */\\nModuleLoader.URL_MAX_LENGTH_ = 4043;\\n\\n\\n/**\\n * Error code for javascript syntax and network errors.\\n * TODO(user): Detect more accurate error info.\\n * @const {number}\\n * @private\\n */\\nModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_ = -1;\\n\\n\\n\\n/**\\n * @param {!TrustedResourceUrl} url The url to be loaded.\\n * @return {!HTMLScriptElement}\\n * @private\\n */\\nModuleLoader.createScriptElement_ = function(url) {\\n  const script = dom.createElement(TagName.SCRIPT);\\n  safe.setScriptSrc(script, url);\\n\\n  // Set scriptElt.async = false to guarantee\\n  // that scripts are loaded in parallel but executed in the insertion order.\\n  // For more details, check\\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\\n  script.async = false;\\n  return script;\\n};\\n\\n\\n/**\\n * @param {!TrustedResourceUrl} url The url to be pre-loaded.\\n * @return {!HTMLLinkElement}\\n * @private\\n */\\nModuleLoader.createPreloadScriptElement_ = function(url) {\\n  const link = dom.createElement(TagName.LINK);\\n  safe.setLinkHrefAndRel(link, url, 'preload');\\n  link.as = 'script';\\n\\n  // If CSP nonces are used, propagate them to dynamically created scripts.\\n  // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\\n  const nonce = safe.getScriptNonce();\\n  if (nonce) {\\n    link.setAttribute('nonce', nonce);\\n  }\\n\\n  return link;\\n};\\n\\n\\n/**\\n * Gets the debug mode for the loader.\\n * @return {boolean} Whether the debug mode is enabled.\\n */\\nModuleLoader.prototype.getDebugMode = function() {\\n  return this.debugMode_;\\n};\\n\\n\\n/**\\n * @param {boolean} useScriptTags Whether or not to use script tags\\n *     (with async=false) for loading.\\n */\\nModuleLoader.prototype.setUseScriptTags = function(useScriptTags) {\\n  this.useScriptTags_ = useScriptTags;\\n};\\n\\n\\n/**\\n * Gets whether we're using non-async script tags for loading.\\n * @return {boolean} Whether or not we're using non-async script tags for\\n *     loading.\\n */\\nModuleLoader.prototype.getUseScriptTags = function() {\\n  return this.useScriptTags_;\\n};\\n\\n\\n/**\\n * Sets whether we're using non-async script tags for loading.\\n * @param {boolean} debugMode Whether the debug mode is enabled.\\n */\\nModuleLoader.prototype.setDebugMode = function(debugMode) {\\n  this.debugMode_ = debugMode;\\n};\\n\\n\\n/**\\n * When enabled, we will add a sourceURL comment to the end of all scripts\\n * to mark their origin.\\n *\\n * On WebKit, stack traces will reflect the sourceURL comment, so this is\\n * useful for debugging webkit stack traces in production.\\n *\\n * Notice that in debug mode, we will use source url injection + eval rather\\n * then appending script nodes to the DOM, because the scripts will load far\\n * faster.  (Appending script nodes is very slow, because we can't parallelize\\n * the downloading and evaling of the script).\\n *\\n * The cost of appending sourceURL information is negligible when compared to\\n * the cost of evaling the script. Almost all clients will want this on.\\n *\\n * TODO(nicksantos): Turn this on by default. We may want to turn this off\\n * for clients that inject their own sourceURL.\\n *\\n * @param {boolean} enabled Whether source url injection is enabled.\\n */\\nModuleLoader.prototype.setSourceUrlInjection = function(enabled) {\\n  this.sourceUrlInjection_ = enabled;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether we're using source url injection.\\n * @private\\n */\\nModuleLoader.prototype.usingSourceUrlInjection_ = function() {\\n  return this.sourceUrlInjection_ ||\\n      (this.getDebugMode() && ModuleLoader.supportsSourceUrlStackTraces());\\n};\\n\\n\\n/** @override */\\nModuleLoader.prototype.loadModules = function(\\n    ids, moduleInfoMap, {forceReload, onError, onSuccess, onTimeout} = {}) {\\n  const loadStatus = this.loadingModulesStatus_[ids] ||\\n      ModuleLoader.LoadStatus.createForIds_(ids, moduleInfoMap);\\n  loadStatus.loadRequested = true;\\n  if (loadStatus.successFn && onSuccess) {\\n    // If there already exists a success function, chain it before the passed\\n    // success functon.\\n    loadStatus.successFn = functions.sequence(loadStatus.successFn, onSuccess);\\n  } else {\\n    loadStatus.successFn = onSuccess || loadStatus.successFn;\\n  }\\n  loadStatus.errorFn = onError || null;\\n\\n  if (!this.loadingModulesStatus_[ids]) {\\n    // Modules were not prefetched.\\n    this.loadingModulesStatus_[ids] = loadStatus;\\n    this.downloadModules_(ids);\\n    // TODO(user): Need to handle timeouts in the module loading code.\\n  } else if (this.getUseScriptTags()) {\\n    // We started prefetching but we used <link rel=\\\"preload\\\".../> tags, so we\\n    // rely on the browser to reconcile the (existing) prefetch request and the\\n    // script tag we're about to insert.\\n    this.downloadModules_(ids);\\n  } else if (loadStatus.responseTexts != null) {\\n    // Modules prefetch is complete.\\n    this.evaluateCode_(ids);\\n  }\\n  // Otherwise modules prefetch is in progress, and these modules will be\\n  // executed after the prefetch is complete.\\n};\\n\\n\\n/**\\n * Evaluate the JS code.\\n * @param {!Array<string>} moduleIds The module ids.\\n * @private\\n */\\nModuleLoader.prototype.evaluateCode_ = function(moduleIds) {\\n  this.dispatchEvent(new ModuleLoader.RequestSuccessEvent(moduleIds));\\n\\n  log.info(this.logger, 'evaluateCode ids:' + moduleIds);\\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\\n  const uris = loadStatus.requestUris;\\n  const texts = loadStatus.responseTexts;\\n  let error = null;\\n  try {\\n    if (this.usingSourceUrlInjection_()) {\\n      for (let i = 0; i < uris.length; i++) {\\n        const script = legacyconversions.safeScriptFromString(\\n            texts[i] + ' //# sourceURL=' + uris[i]);\\n        goog.globalEval(SafeScript.unwrapTrustedScript(script));\\n      }\\n    } else {\\n      const script = legacyconversions.safeScriptFromString(texts.join('\\\\n'));\\n      goog.globalEval(SafeScript.unwrapTrustedScript(script));\\n    }\\n  } catch (e) {\\n    error = e;\\n    // TODO(user): Consider throwing an exception here.\\n    log.warning(\\n        this.logger, 'Loaded incomplete code for module(s): ' + moduleIds, e);\\n  }\\n\\n  this.dispatchEvent(new ModuleLoader.EvaluateCodeEvent(moduleIds));\\n\\n  if (error) {\\n    this.handleErrorHelper_(\\n        moduleIds, loadStatus.errorFn, null /* status */, error);\\n  } else if (loadStatus.successFn) {\\n    loadStatus.successFn();\\n  }\\n  delete this.loadingModulesStatus_[moduleIds];\\n};\\n\\n\\n/**\\n * Handles a successful response to a request for prefetch or load one or more\\n * modules.\\n *\\n * @param {!BulkLoader} bulkLoader The bulk loader.\\n * @param {!Array<string>} moduleIds The ids of the modules requested.\\n * @private\\n */\\nModuleLoader.prototype.handleSuccess_ = function(bulkLoader, moduleIds) {\\n  log.info(this.logger, 'Code loaded for module(s): ' + moduleIds);\\n\\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\\n  loadStatus.responseTexts = bulkLoader.getResponseTexts();\\n\\n  if (loadStatus.loadRequested) {\\n    this.evaluateCode_(moduleIds);\\n  }\\n\\n  // NOTE: A bulk loader instance is used for loading a set of module ids.\\n  // Once these modules have been loaded successfully or in error the bulk\\n  // loader should be disposed as it is not needed anymore. A new bulk loader\\n  // is instantiated for any new modules to be loaded. The dispose is called\\n  // on a timer so that the bulkloader has a chance to release its\\n  // objects.\\n  Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\\n};\\n\\n\\n/** @override */\\nModuleLoader.prototype.prefetchModule = function(id, moduleInfo) {\\n  // Do not prefetch in debug mode\\n  if (this.getDebugMode()) {\\n    return;\\n  }\\n  log.info(this.logger, `Prefetching module: ${id}`);\\n  let loadStatus = this.loadingModulesStatus_[[id]];\\n  if (loadStatus) {\\n    return;\\n  }\\n  const moduleInfoMap = {};\\n  moduleInfoMap[id] = moduleInfo;\\n  loadStatus = ModuleLoader.LoadStatus.createForIds_([id], moduleInfoMap);\\n  this.loadingModulesStatus_[[id]] = loadStatus;\\n  if (this.getUseScriptTags()) {\\n    const links = [];\\n    const insertPos = document.head || document.documentElement;\\n    for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\\n      const link = ModuleLoader.createPreloadScriptElement_(\\n          loadStatus.trustedRequestUris[i]);\\n      links.push(link);\\n      insertPos.insertBefore(link, insertPos.firstChild);\\n    }\\n    loadStatus.successFn = () => {\\n      for (let i = 0; i < links.length; i++) {\\n        const link = links[i];\\n        dom.removeNode(link);\\n      }\\n    };\\n  } else {\\n    this.downloadModules_([id]);\\n  }\\n};\\n\\n\\n/**\\n * Downloads a list of JavaScript modules.\\n *\\n * @param {!Array<string>} ids The module ids in dependency order.\\n * @private\\n */\\nModuleLoader.prototype.downloadModules_ = function(ids) {\\n  const debugMode = this.getDebugMode();\\n  const sourceUrlInjection = this.usingSourceUrlInjection_();\\n  const useScriptTags = this.getUseScriptTags();\\n  if ((debugMode + sourceUrlInjection + useScriptTags) > 1) {\\n    const effectiveFlag = useScriptTags ?\\n        'useScriptTags' :\\n        (debugMode && !sourceUrlInjection) ? 'debug' : 'sourceUrlInjection';\\n    log.warning(\\n        this.logger,\\n        `More than one of debugMode (set to ${debugMode}), ` +\\n            `useScriptTags (set to ${useScriptTags}), ` +\\n            `and sourceUrlInjection (set to ${sourceUrlInjection}) ` +\\n            `is enabled. Proceeding with download as if ` +\\n            `${effectiveFlag} is set to true and the rest to false.`);\\n  }\\n  const loadStatus = asserts.assert(this.loadingModulesStatus_[ids]);\\n\\n  if (useScriptTags) {\\n    this.loadWithNonAsyncScriptTag_(loadStatus, ids);\\n  } else if (debugMode && !sourceUrlInjection) {\\n    // In debug mode use <script> tags rather than XHRs to load the files.\\n    // This makes it possible to debug and inspect stack traces more easily.\\n    // It's also possible to use it to load JavaScript files that are hosted on\\n    // another domain.\\n    // The scripts need to load serially, so this is much slower than parallel\\n    // script loads with source url injection.\\n    jsloader.safeLoadMany(loadStatus.trustedRequestUris);\\n  } else {\\n    log.info(\\n        this.logger,\\n        'downloadModules ids:' + ids + ' uris:' + loadStatus.requestUris);\\n\\n    const bulkLoader = new BulkLoader(loadStatus.requestUris);\\n\\n    const eventHandler = this.eventHandler_;\\n    eventHandler.listen(\\n        bulkLoader, EventType.SUCCESS,\\n        goog.bind(this.handleSuccess_, this, bulkLoader, ids));\\n    eventHandler.listen(\\n        bulkLoader, EventType.ERROR,\\n        goog.bind(this.handleError_, this, bulkLoader, ids));\\n    bulkLoader.load();\\n  }\\n};\\n\\n\\n/**\\n * Downloads a list of script URIS using <script async=false.../>, which\\n * guarantees executuion order.\\n * @param {!ModuleLoader.LoadStatus} loadStatus The load status\\n *     object for this module-load.\\n *  @param {!Array<string>} ids The module ids in dependency order.\\n * @private\\n */\\nModuleLoader.prototype.loadWithNonAsyncScriptTag_ = function(loadStatus, ids) {\\n  log.info(this.logger, `Loading initiated for: ${ids}`);\\n  if (loadStatus.trustedRequestUris.length == 0) {\\n    if (loadStatus.successFn) {\\n      loadStatus.successFn();\\n      return;\\n    }\\n  }\\n\\n  // We'll execute the success callback when the last script enqueed reaches\\n  // onLoad.\\n  let lastScript = null;\\n  const insertPos = document.head || document.documentElement;\\n\\n  for (let i = 0; i < loadStatus.trustedRequestUris.length; i++) {\\n    const url = loadStatus.trustedRequestUris[i];\\n    const urlLength = loadStatus.requestUris[i].length;\\n    asserts.assert(\\n        urlLength <= ModuleLoader.URL_MAX_LENGTH_,\\n        `Module url length is ${urlLength}, which is greater than limit of ` +\\n            `${ModuleLoader.URL_MAX_LENGTH_}. This should never ` +\\n            `happen.`);\\n\\n    const scriptElement = ModuleLoader.createScriptElement_(url);\\n\\n    scriptElement.onload = () => {\\n      scriptElement.onload = null;\\n      scriptElement.onerror = null;\\n      dom.removeNode(scriptElement);\\n      if (scriptElement == lastScript) {\\n        log.info(this.logger, `Loading complete for: ${ids}`);\\n        lastScript = null;\\n        if (loadStatus.successFn) {\\n          loadStatus.successFn();\\n        }\\n      }\\n    };\\n\\n    scriptElement.onerror = () => {\\n      log.error(this.logger, `Network error when loading module(s): ${ids}`);\\n      scriptElement.onload = null;\\n      scriptElement.onerror = null;\\n      dom.removeNode(scriptElement);\\n      this.handleErrorHelper_(\\n          ids, loadStatus.errorFn, ModuleLoader.SYNTAX_OR_NETWORK_ERROR_CODE_);\\n      if (lastScript == scriptElement) {\\n        lastScript = null;\\n      } else {\\n        log.error(\\n            this.logger,\\n            `Dependent requests were made in parallel with failed request ` +\\n                `for module(s) \\\"${ids}\\\". Non-recoverable out-of-order ` +\\n                `execution may occur.`);\\n      }\\n    };\\n    lastScript = scriptElement;\\n    insertPos.insertBefore(scriptElement, insertPos.firstChild);\\n  }\\n};\\n\\n\\n/**\\n * Handles an error during a request for one or more modules.\\n * @param {!BulkLoader} bulkLoader The bulk loader.\\n * @param {!Array<string>} moduleIds The ids of the modules requested.\\n * @param {!BulkLoader.LoadErrorEvent} event The load error event.\\n * @private\\n */\\nModuleLoader.prototype.handleError_ = function(bulkLoader, moduleIds, event) {\\n  const loadStatus = this.loadingModulesStatus_[moduleIds];\\n  // The bulk loader doesn't cancel other requests when a request fails. We will\\n  // delete the loadStatus in the first failure, so it will be undefined in\\n  // subsequent errors.\\n  if (loadStatus) {\\n    delete this.loadingModulesStatus_[moduleIds];\\n    this.handleErrorHelper_(moduleIds, loadStatus.errorFn, event.status);\\n  }\\n\\n  // NOTE: A bulk loader instance is used for loading a set of module ids. Once\\n  // these modules have been loaded successfully or in error the bulk loader\\n  // should be disposed as it is not needed anymore. A new bulk loader is\\n  // instantiated for any new modules to be loaded. The dispose is called\\n  // on another thread so that the bulkloader has a chance to release its\\n  // objects.\\n  Timer.callOnce(bulkLoader.dispose, 5, bulkLoader);\\n};\\n\\n\\n/**\\n * Handles an error during a request for one or more modules.\\n * @param {!Array<string>} moduleIds The ids of the modules requested.\\n * @param {?function(?number)} errorFn The function to call on failure.\\n * @param {?number} status The response status.\\n * @param {!Error=} opt_error The error encountered, if available.\\n * @private\\n */\\nModuleLoader.prototype.handleErrorHelper_ = function(\\n    moduleIds, errorFn, status, opt_error) {\\n  this.dispatchEvent(\\n      new ModuleLoader.RequestErrorEvent(moduleIds, status, opt_error));\\n\\n  log.warning(this.logger, 'Request failed for module(s): ' + moduleIds);\\n\\n  if (errorFn) {\\n    errorFn(status);\\n  }\\n};\\n\\n\\n/**\\n * Events dispatched by the ModuleLoader.\\n * @const\\n */\\nModuleLoader.EventType = {\\n  /**\\n   * @const {!EventId<\\n   *     !ModuleLoader.EvaluateCodeEvent>} Called after the code for\\n   *     a module is evaluated.\\n   */\\n  EVALUATE_CODE: new EventId(events.getUniqueId('evaluateCode')),\\n\\n  /**\\n   * @const {!EventId<\\n   *     !ModuleLoader.RequestSuccessEvent>} Called when the\\n   *     BulkLoader finishes successfully.\\n   */\\n  REQUEST_SUCCESS: new EventId(events.getUniqueId('requestSuccess')),\\n\\n  /**\\n   * @const {!EventId<\\n   *     !ModuleLoader.RequestErrorEvent>} Called when the\\n   *     BulkLoader fails, or code loading fails.\\n   */\\n  REQUEST_ERROR: new EventId(events.getUniqueId('requestError'))\\n};\\n\\n\\n\\n/**\\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\\n * @constructor\\n * @extends {GoogEvent}\\n * @final\\n * @protected\\n */\\nModuleLoader.EvaluateCodeEvent = function(moduleIds) {\\n  ModuleLoader.EvaluateCodeEvent.base(\\n      this, 'constructor', ModuleLoader.EventType.EVALUATE_CODE);\\n\\n  /**\\n   * @type {!Array<string>}\\n   */\\n  this.moduleIds = moduleIds;\\n};\\ngoog.inherits(ModuleLoader.EvaluateCodeEvent, GoogEvent);\\n\\n\\n\\n/**\\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\\n * @constructor\\n * @extends {GoogEvent}\\n * @final\\n * @protected\\n */\\nModuleLoader.RequestSuccessEvent = function(moduleIds) {\\n  ModuleLoader.RequestSuccessEvent.base(\\n      this, 'constructor', ModuleLoader.EventType.REQUEST_SUCCESS);\\n\\n  /**\\n   * @type {!Array<string>}\\n   */\\n  this.moduleIds = moduleIds;\\n};\\ngoog.inherits(ModuleLoader.RequestSuccessEvent, GoogEvent);\\n\\n\\n\\n/**\\n * @param {!Array<string>} moduleIds The ids of the modules being evaluated.\\n * @param {?number} status The response status.\\n * @param {!Error=} opt_error The error encountered, if available.\\n * @constructor\\n * @extends {GoogEvent}\\n * @final\\n * @protected\\n */\\nModuleLoader.RequestErrorEvent = function(moduleIds, status, opt_error) {\\n  ModuleLoader.RequestErrorEvent.base(\\n      this, 'constructor', ModuleLoader.EventType.REQUEST_ERROR);\\n\\n  /**\\n   * @type {?Array<string>}\\n   */\\n  this.moduleIds = moduleIds;\\n\\n  /** @type {?number} */\\n  this.status = status;\\n\\n  /** @type {?Error} */\\n  this.error = opt_error || null;\\n};\\ngoog.inherits(ModuleLoader.RequestErrorEvent, GoogEvent);\\n\\n\\n\\n/**\\n * A class that keeps the state of the module during the loading process. It is\\n * used to save loading information between modules download and evaluation.\\n *  @param {!Array<!TrustedResourceUrl>} trustedRequestUris the uris\\n containing the modules implementing ids.\\n\\n * @constructor\\n * @final\\n */\\nModuleLoader.LoadStatus = function(trustedRequestUris) {\\n  /**\\n   * The request uris.\\n   * @final {!Array<string>}\\n   */\\n  this.requestUris = trustedRequestUris.map(TrustedResourceUrl.unwrap);\\n\\n  /**\\n   * A TrustedResourceUrl version of `this.requestUris`\\n   * @final {!Array<!TrustedResourceUrl>}\\n   */\\n  this.trustedRequestUris = trustedRequestUris;\\n\\n  /**\\n   * The response texts.\\n   * @type {?Array<string>}\\n   */\\n  this.responseTexts = null;\\n\\n  /**\\n   * Whether loadModules was called for the set of modules referred by this\\n   * status.\\n   * @type {boolean}\\n   */\\n  this.loadRequested = false;\\n\\n  /**\\n   * Success callback.\\n   * @type {?function()}\\n   */\\n  this.successFn = null;\\n\\n  /**\\n   * Error callback.\\n   * @type {?function(?number)}\\n   */\\n  this.errorFn = null;\\n};\\n\\n\\n/**\\n * Creates a `LoadStatus` object for tracking state during the loading of the\\n * modules indexed in `ids`.\\n *\\n * @param {?Array<string>} ids the ids for this module load in dependency\\n *   order.\\n * @param {!Object<string, !ModuleInfo>} moduleInfoMap A mapping\\n *     from module id to ModuleInfo object.\\n * @return {!ModuleLoader.LoadStatus}\\n * @private\\n */\\nModuleLoader.LoadStatus.createForIds_ = function(ids, moduleInfoMap) {\\n  if (!ids) {\\n    return new ModuleLoader.LoadStatus([]);\\n  }\\n  const trustedRequestUris = [];\\n  for (let i = 0; i < ids.length; i++) {\\n    googArray.extend(trustedRequestUris, moduleInfoMap[ids[i]].getUris());\\n  }\\n  return new ModuleLoader.LoadStatus(trustedRequestUris);\\n};\\n\\n\\nexports = ModuleLoader;\\n\"],\n\"names\":[\"ModuleLoader\",\"base\",\"eventHandler_\",\"EventHandler\",\"registerDisposable\",\"loadingModulesStatus_\",\"goog\",\"module\",\"AbstractModuleLoader\",\"require\",\"BulkLoader\",\"EventId\",\"EventTarget\",\"EventType\",\"GoogEvent\",\"ModuleInfo\",\"requireType\",\"SafeScript\",\"TagName\",\"Timer\",\"TrustedResourceUrl\",\"asserts\",\"browser\",\"dom\",\"events\",\"functions\",\"googArray\",\"jsloader\",\"legacyconversions\",\"log\",\"product\",\"safe\",\"userAgent\",\"inherits\",\"prototype\",\"logger\",\"getLogger\",\"debugMode_\",\"sourceUrlInjection_\",\"useScriptTags_\",\"supportsSourceUrlStackTraces\",\"ModuleLoader.supportsSourceUrlStackTraces\",\"CHROME\",\"isFirefox\",\"isVersionOrHigher\",\"supportsSourceUrlDebugger\",\"ModuleLoader.supportsSourceUrlDebugger\",\"GECKO\",\"URL_MAX_LENGTH_\",\"SYNTAX_OR_NETWORK_ERROR_CODE_\",\"createScriptElement_\",\"ModuleLoader.createScriptElement_\",\"url\",\"script\",\"createElement\",\"SCRIPT\",\"setScriptSrc\",\"async\",\"createPreloadScriptElement_\",\"ModuleLoader.createPreloadScriptElement_\",\"link\",\"LINK\",\"setLinkHrefAndRel\",\"as\",\"nonce\",\"getScriptNonce\",\"setAttribute\",\"getDebugMode\",\"ModuleLoader.prototype.getDebugMode\",\"setUseScriptTags\",\"ModuleLoader.prototype.setUseScriptTags\",\"useScriptTags\",\"getUseScriptTags\",\"ModuleLoader.prototype.getUseScriptTags\",\"setDebugMode\",\"ModuleLoader.prototype.setDebugMode\",\"debugMode\",\"setSourceUrlInjection\",\"ModuleLoader.prototype.setSourceUrlInjection\",\"enabled\",\"usingSourceUrlInjection_\",\"ModuleLoader.prototype.usingSourceUrlInjection_\",\"loadModules\",\"ModuleLoader.prototype.loadModules\",\"ids\",\"moduleInfoMap\",\"forceReload\",\"onError\",\"onSuccess\",\"onTimeout\",\"loadStatus\",\"LoadStatus\",\"createForIds_\",\"loadRequested\",\"successFn\",\"sequence\",\"errorFn\",\"downloadModules_\",\"responseTexts\",\"evaluateCode_\",\"ModuleLoader.prototype.evaluateCode_\",\"moduleIds\",\"dispatchEvent\",\"RequestSuccessEvent\",\"info\",\"uris\",\"requestUris\",\"texts\",\"error\",\"i\",\"length\",\"safeScriptFromString\",\"globalEval\",\"unwrapTrustedScript\",\"join\",\"e\",\"warning\",\"EvaluateCodeEvent\",\"handleErrorHelper_\",\"handleSuccess_\",\"ModuleLoader.prototype.handleSuccess_\",\"bulkLoader\",\"getResponseTexts\",\"callOnce\",\"dispose\",\"prefetchModule\",\"ModuleLoader.prototype.prefetchModule\",\"id\",\"moduleInfo\",\"links\",\"insertPos\",\"document\",\"head\",\"documentElement\",\"trustedRequestUris\",\"push\",\"insertBefore\",\"firstChild\",\"loadStatus.successFn\",\"removeNode\",\"ModuleLoader.prototype.downloadModules_\",\"sourceUrlInjection\",\"effectiveFlag\",\"assert\",\"loadWithNonAsyncScriptTag_\",\"safeLoadMany\",\"eventHandler\",\"listen\",\"SUCCESS\",\"bind\",\"ERROR\",\"handleError_\",\"load\",\"ModuleLoader.prototype.loadWithNonAsyncScriptTag_\",\"lastScript\",\"urlLength\",\"scriptElement\",\"onload\",\"scriptElement.onload\",\"onerror\",\"scriptElement.onerror\",\"ModuleLoader.prototype.handleError_\",\"event\",\"status\",\"ModuleLoader.prototype.handleErrorHelper_\",\"opt_error\",\"RequestErrorEvent\",\"EVALUATE_CODE\",\"getUniqueId\",\"REQUEST_SUCCESS\",\"REQUEST_ERROR\",\"ModuleLoader.EvaluateCodeEvent\",\"ModuleLoader.RequestSuccessEvent\",\"ModuleLoader.RequestErrorEvent\",\"ModuleLoader.LoadStatus\",\"map\",\"unwrap\",\"ModuleLoader.LoadStatus.createForIds_\",\"extend\",\"getUris\",\"exports\"]\n}\n"]